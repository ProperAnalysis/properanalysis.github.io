<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>bitView</title>
<style>

:root {
    --backgroundLight: #ffffff;
    --midgroundLight: #efefef;
    --borderColorLight: #8d8d8d;
    --buttonbgLight: #e5e5e5;
    --entrybgLight: #efefef;
    --backgroundLight: #e2fcff;
    --midgroundLight: #efefef;
    --borderColorLight: #2c2c2c;
    --buttonbgLight: #e2fcff;
    --entrybgLight: #ffffff;
    --buttonbgHoverLight: #54fff5;
    --buttonbgSelectedLight: #54fff5;
    --buttonfgSelectedLight: #000;
    --textColorLight: #000;
    --tableHeadColorLight: #005861;
    --tableHighlightColorLight: #910000;
    --tableHighlightColorLight2: #84006c;
    --cellColorLight: #ffffff;
    --cellBorderLight: #9e9e9e;
    --cellBorderStrongLight: #666;
    --shadowColorLight: #fff;
    --tableTopLeftLight: #fff;
    --bitRasterBgLight: #efefef;
    
    --backgroundDark: #092a30;
    --midgroundDark: #000;
    --borderColorDark: #bafbff;
    --entrybgDark: #222;
    --buttonbgDark: #003a2f;
    --buttonbgHoverDark: #009a85;
    --buttonbgSelectedDark: #00ffd1;
    --buttonfgSelectedDark: #000;
    --textColorDark: #ccfff8;
    --tableHeadColorDark: #4bffc5;
    --tableHighlightColorDark: #ff8383;
    --tableHighlightColorDark2: #e78bff;
    --cellColorDark: #050505;
    --cellBorderDark: #606060;
    --cellBorderStrongDark: #777;
    --shadowColorDark: #000;
    --tableTopLeftDark: #484848;
    --bitRasterBgDark: #222;
    
    --background: var(--backgroundDark);
    --midground: var(--midgroundDark);
    --borderColor: var(--borderColorDark);
    --buttonbg: var(--buttonbgDark);
    --entrybg: var(--entrybgDark);
    --buttonbgHover: var(--buttonbgHoverDark);
    --buttonbgSelected: var(--buttonbgSelectedDark);
    --buttonfgSelected: var(--buttonfgSelectedDark);
    --textColor: var(--textColorDark);
    --tableHeadColor: var(--tableHeadColorDark);
    --tableHighlightColor: var(--tableHighlightColorDark);
    --tableHighlightColor2: var(--tableHighlightColorDark2);
    --cellColor: var(--cellColorDark);
    --cellBorder: var(--cellBorderDark);
    --cellBorderStrong: var(--cellBorderStrongDark);
    --shadowColor: var(--shadowColorDark);
    --tableTopLeft: var(--tableTopLeftDark);
    --tableTopLeft: var(--tableTopLeftDark);
    --bitRasterBg: var(--bitRasterBgDark);
}

*::-webkit-scrollbar {
    -webkit-appearance: none;
}
*::-webkit-scrollbar:vertical {
    width: 5px;
}
*::-webkit-scrollbar:horizontal {
    height: 5px;
}
*::-webkit-scrollbar-thumb {
	border-radius: 3px;
    border: 1px solid var(--borderColor);
    background-Color: var(--buttonbg);
}
*::-webkit-scrollbar-track { 
	border-radius: 3px;
    border: none;
    background-Color: var(--midground);
} 

::-webkit-scrollbar-corner {
    background-Color: var(--midground); 
}

html, body {
	margin: 0; 
	height: 100%; 
	overflow: hidden;
	background-color: var(--background);
}


div {
	transition: max-height 0s;
}

#container {
	width: 100%;
	height: 100%;
	font-family: 'Comic Sans MS', 'Comic Sans', cursive;
	font-size: 12pt;
	color: var(--textColor);
	position: absolute;
	display: flex;
	flex-direction: column;
}


#topMenu {
	height: auto;
    width: calc(100% - 23px);
    margin-top: 10px;
    display: block;
    flex-shrink: 0;
    flex-grow: 0;
    z-index: 1;
    margin-left: 10px;
    background: var(--midground);
    border-radius: 4px;
    border: 1px solid var(--borderColor);
}

.topMenuItem {
    float: left;
    margin: 5px;
    padding: 5px;
    padding-right: 15px;
    border-right: 1px var(--borderColor) solid;
    z-index: 1;
    padding-top: 2px;
    padding-bottom: 0px;
}

.closedToolbox {
	visibility: hidden;
	width: 100%;
	height: 0px;
	max-height: 0px;
}

.openToolbox {
    visibility: unset;
    width: calc(100% - 5px);
    height: auto;
    margin: 0px;
    padding: 5px;
    padding-left: 0px;
    max-height: 9001;
    z-index: 1;
    border-top: 1px solid var(--borderColor);
    margin-top: 5px;
    padding-bottom: 0px;
}

#bitRasterOuter {
    background-color: var(--midground);
    width: calc(100% - 42px);
    padding: 10px;
    margin: 10px;
    margin-top: 10px;
    margin-bottom: 5px;
    border-radius: 5px;
    border: 1px var(--borderColor) solid;
    flex-shrink: 1;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    max-height: 100%;
    margin-bottom: -10px;
    padding-bottom: 20px;
}

#bitRasterInner {
    overflow: scroll;
    height: 1;
    width: 100%;
    flex-shrink: 1;
    flex-grow: 1
}



#bottomMenuContainer {
	background-color: var(--midground);
    width: calc(100% - 43px);
    height: fit-content;
    padding: 10px;
    margin: 10px;
    margin-bottom: 0px;
    border-radius: 5px;
    overflow: hidden;
    border: 1px var(--borderColor) solid;
    flex-shrink: 0;
    flex-grow: 0;
    z-index: 1;
    margin-top: -10px;
    padding-top: 20px;
}

#bottomMenu {
	width: 100%;
	z-index: 1;
}


button, input::file-selector-button, input[type="number"], input[type="text"], select{
	background-Color: var(--entrybg);
	border: 1px var(--borderColor) solid;
	border-radius: 2px;
    Color: var(--textColor);
    margin: 0px;
    font-family: "Comic Sans MS", "Comic Sans", cursive;
    outline: none;
    margin-bottom: 3px;
}

button {
	background-Color: var(--buttonbg);
}

input[type="number"], input[type="text"], select {
	width: 6em;
    font-family: "Comic Sans MS", "Comic Sans", cursive;
}

button:hover, input::file-selector-button:hover{
	background-Color: var(--buttonbgHover);
}

.opsConfig {
	margin: 10px;
	overflow-y: scroll;
	width: auto;
	height: calc(100% - 40pt);
	font-size: 10pt;
}

.opsConfigHidden {
	display: none;
}

textArea {
	resize: none;
    background: var(--midground);
    Color: var(--textColor);
    border: none;
    padding: 0px;
    outline: none;
    font-family: monospace;
}

</style>
</head>

<body>
<canvas width="1920" height="969" id="background" style="position: absolute; z-index: 0;"></canvas>
<div id="container">

<div id="bottomMenuContainer">
<div id="bottomMenu">
<button id="inputMenuButton" onclick="openToolbox(&#39;inputMenu&#39;);" style="">Input Select</button>
<button id="findWidthButton" onclick="openToolbox(&#39;findWidth&#39;);">Find Width</button>
<button id="columnBiasButton" onclick="openToolbox(&#39;columnBias&#39;);">Column Bias</button>
<button id="asciiViewButton" onclick="openToolbox(&#39;asciiView&#39;); updateAsciiView();">ASCII View</button>
<button id="hexViewButton" onclick="openToolbox(&#39;hexView&#39;); updateHexView();" style="">Hex View</button>
<button id="binaryViewButton" onclick="openToolbox(&#39;binaryView&#39;); updateBinaryView();">Binary View</button>
<button id="operationsButton" onclick="openToolbox(&#39;operations&#39;)" style="">Operations</button>
<button id="outputMenuButton" onclick="openToolbox(&#39;outputMenu&#39;);">Output</button>
<button id="playAudioButton" onclick="openToolbox(&#39;playAudio&#39;);">Play Audio</button>
<button id="outputMenuButton" onclick="toggleColorMode();">Light/Dark</button>
</div>


<div id="inputMenu" class="closedToolbox">
<p style="width: 100%;">Load from file:</p>
<input type="file" id="fileSelector">
<p style="width: 100%; border-top: 1px solid var(--borderColor); padding-top: 10px;">OR load from text:</p>
<textarea id="textInputArea" style="font-family: 'Comic Sans MS', 'Comic Sans', cursive; color: var(--textColor); width: 100%; height: 265px; background-color: var(--midground); border: 1px solid var(--borderColor);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
<button onclick="loadTextInput(2);">Load Binary</button>
<button onclick="loadTextInput(16);">Load Hex</button>
</div>

<div id="playAudio" class="closedToolbox">
<div style="display: block;">
<div style="height: 150px;" id='specanContainer'></div>
<p>Sample Rate: <input type="number" id="sampleRateInput" min=1 value=8000></input>
<button style="margin-left: 10px;" onclick="playAudio();">Generate and Play</button>
<button style="margin-left: 10px;" id='displaySpecanButton'>Display SpecAn</button></p>
<audio controls="controls" id="audio" loop>
<source id="source" src="" type="audio/wav" />
</audio>
</div>
</div>

<div id="outputMenu" class="closedToolbox">
<div style="display: flex;">
<button id="outputGenerateButton" onclick="generateOutput();">Generate Output</button><div id="outputList" style="font-size: 8pt; margin-left: 10px; margin-top: 5px;"></div>
</div>
</div>

<div id="findWidth" class="closedToolbox">
<canvas id="findWidthGraph" width="1" height="265" style="border: 0px; position: absolute; left: 20px; z-index: 0; visibility: hidden;"></canvas>
<canvas id="findWidthOverlay" onmousemove="getMousePos(event)" onclick="applyWidth(event)" width="1" height="265" style="visibility: hidden; border: 0px; position: absolute; left: 20px; z-index: 1;"></canvas>
<div id="spacer" style="width: 100%; height: 265px;"></div>
<div style="padding-top: 5px; padding-right: 10px;">
Min Width: <input type="number" id="minWidthInput" value="0">
Max Width: <input type="number" id="maxWidthInput" value="1000">
Bits to Test: <input type="number" id="testBitsInput" value="100000">
<button id="goFindWidthButton" onclick="findWidth();">Go</button>
</div>
</div>

<div id="columnBias" class="closedToolbox">
<canvas id="columnBiasGraph" width="1" height="155" style="border: 0px; position: absolute; left: 20px; z-index: 0; visibility: hidden; margin-bottom: 10px;"></canvas>
<div id="spacer" style="width: 100%; height: 165px;"></div>
<textarea disabled="" id="columnBiasOutput" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; font-family: monospace; color: var(--textColor); width: 100%; height: auto; background-color: var(--midground);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" ></textarea>
<div style="padding-top: 5px; padding-right: 10px;">
Bits to Test: <input type="number" id="columnBiasInput" value="100000">
<button id="goColumnBiasButton" onclick="runColumnBias();">Go</button>
</div>
</div>


<div id="asciiView" class="closedToolbox">
<textarea disabled="" id="asciiViewOutput" style="font-family: monospace; color: var(--textColor); width: 100%; height: 265px; background-color: var(--midground);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" ></textarea>
</div>

<div id="hexView" class="closedToolbox">
<textarea disabled="" id="hexViewOutput" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; font-family: monospace; color: var(--textColor); width: 100%; height: 265px; background-color: var(--midground);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
</div>

<div id="binaryView" class="closedToolbox">
<button onclick="loadFullBinaryView();">Load All</button>
<select id="binaryViewType">
	<option>standard view</option>
	<option>.x view</option>
</select>
<select id="binaryViewSpacing">
	<option>bit spaced</option>
	<option>byte spaced</option>
</select>
<textarea disabled="" id="binaryViewOutput" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; font-family: monospace; color: var(--textColor); width: 100%; height: 265px; background-color: var(--midground);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" ></textarea>
</div>

<div id="operations" class="closedToolbox" style="overflow-y: hidden; overflow-x: hidden; display: -webkit-box;">

<div id="operationTypes" style="width: 20%; overflow-y: scroll; height: 270px; padding-right: 5px; margin-right: 5px;">
<p style="text-align: center;">Operations Menu</p>
<button style="width: 100%;" onclick="addOperation(&#39;additiveScramble&#39;, [&#39;0,1,7&#39;, &#39;No&#39;, &#39;1&#39;, &#39;0&#39;, &#39;0&#39;]);">additiveScramble</button>
<button style="width: 100%;" onclick="addOperation(&#39;feedThruScramble&#39;, [&#39;0,1,7&#39;, &#39;No&#39;]);">feedThruScramble</button>
<button style="width: 100%;" onclick="addOperation(&#39;feedThruDescramble&#39;, [&#39;0,1,7&#39;, &#39;No&#39;]);">feedThruDescramble</button>
<button style="width: 100%;" onclick="addOperation(&#39;applyDelta&#39;, [1]);">applyDelta</button>
<button style="width: 100%;" onclick="addOperation(&#39;applyXOR&#39;, [&#39;0&#39;, 0]);">applyXOR</button>
<button style="width: 100%;" onclick="addOperation(&#39;frameSync&#39;, [0,0,256]);">frameSync</button>
<button style="width: 100%;" onclick="addOperation(&#39;findPattern&#39;, [0,0]);">findPattern</button>
<button style="width: 100%;" onclick="addOperation(&#39;takeSkip&#39;, [&#39;t256&#39;]);">takeSkip</button>
<button style="width: 100%;" onclick="addOperation(&#39;mergeBits&#39;, [1,50]);">mergeBits</button>
<button style="width: 100%;" onclick="addOperation(&#39;invertBits&#39;, []);">invertBits</button>
<button style="width: 100%;" onclick="addOperation(&#39;repeatBits&#39;, [0, 1]);">repeatBits</button>
<button style="width: 100%;" onclick="addOperation(&#39;snipBits&#39;, [0, 0]);">snipBits</button>
<button style="width: 100%;" onclick="addOperation(&#39;addBits&#39;, [0, 1, &#39;&#39;]);">addBits</button>
<button style="width: 100%;" onclick="addOperation(&#39;spread&#39;, [1]);">spread</button>
<button style="width: 100%;" onclick="addOperation(&#39;fskModulate&#39;, [400,600,100]);">fskModulate</button>
<button style="width: 100%;" onclick="addOperation(&#39;bpskModulate&#39;, [2000,500]);">bpskModulate</button>
<button style="width: 100%;" onclick="addOperation(&#39;qpskModulate&#39;, [2000,500]);">qpskModulate</button>
<button style="width: 100%;" onclick="addOperation(&#39;askModulate&#39;, [2000,500,50]);">askModulate</button>
<button style="width: 100%;" onclick="addOperation(&#39;addNoise&#39;, [1]);">addNoise</button>
<button style="width: 100%;" onclick="addOperation(&#39;firFilter&#39;, [&#39;&#39;]);">FIR Filter</button>
</div>

<div style="width: 1px; background: var(--borderColor);"></div>

<div id="operationsListContainer" style="width: 20%; height: 270px; overflow-y: scroll; margin-left: 10px; margin-right: 5px;">
<p style="text-align: center;">Applied Operations</p>
<div id="operationsList"></div>
</div>

<div style="width: 1px; background: var(--borderColor);"></div>


<div id="operationsConfig" style="width: calc(60% - 15px); height: 270px;">
<p style="text-align: center;">Operation Configuration</p>

<div id="firFilterConfig" class="opsConfigHidden">
<p>FIR Filter</p>
<p>Implements a FIR filter based on a list of floating point coefficients. Assumes that the data is 8 bit/sample PCM. Enter the comma separated coefficients below.</p>
<p><textArea id="firFilter0"></textArea></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="spreadConfig" class="opsConfigHidden">
<p>Spread</p>
<p>Makes use of a spreading code to spread the signal. Can be reversed with the "De-spread" operation. 1s in the data will be replaced with the spreading code. 0s in the data will be replaced with the inverted spreading code.</p>
<p><textArea id="spread0"></textArea></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="addNoiseConfig" class="opsConfigHidden">
<p>Add Noise</p>
<p>Intended for use with PCM audio (8 bits / sample). Adds noise with a given amplitude.</p>
<p>Amplitude: <input type="number" id="addNoise0" value="0"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="askModulateConfig" class="opsConfigHidden">
<p>ASK Modulate</p>
<p>Produces a PCM audio stream of the bits, modulated using amplitude shift keying</p>
<p>Frequency: <input type="number" id="askModulate0" value="2000"></p>
<p>Baud Rate: <input type="number" id="askModulate1" value="100"></p>
<p>Amount (%): <input type="number" id="askModulate2" value="50"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="bpskModulateConfig" class="opsConfigHidden">
<p>BPSK Modulate</p>
<p>Produces a PCM audio stream of the bits, modulated using binary phase shift keying</p>
<p>Frequency: <input type="number" id="bpskModulate0" value="2000"></p>
<p>Baud Rate: <input type="number" id="bpskModulate1" value="500"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="qpskModulateConfig" class="opsConfigHidden">
<p>QPSK Modulate</p>
<p>Produces a PCM audio stream of the bits, modulated using quadrature phase shift keying</p>
<p>Frequency: <input type="number" id="qpskModulate0" value="2000"></p>
<p>Baud Rate: <input type="number" id="qpskModulate1" value="500"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="fskModulateConfig" class="opsConfigHidden">
<p>FSK Modulate</p>
<p>Produces a PCM audio stream of the bits, modulated using frequency shift keying</p>
<p>Low Frequency: <input type="number" id="fskModulate0" value="400"></p>
<p>High Frequency: <input type="number" id="fskModulate1" value="600"></p>
<p>Baud Rate: <input type="number" id="fskModulate2" value="100"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="mergeBitsConfig" class="opsConfigHidden">
<p>Merge Bits</p>
<p>For a given length of bits, takes the average of those bits and makes it into 1 bit. For a bias of 50, any more than 50% of bits being 1 will result in a 1.</p>
<p>Length: <input type="number" id="mergeBits0" value="1" min="1"></p>
<p>Bias: <input type="number" id="mergeBits1" value="50" min="1"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="findPatternConfig" class="opsConfigHidden">
<p>Find Pattern</p>
<p>Matches a pattern within a given hamming distance - matches are filled with 1s. Non-matches are filled with 0s.</p>
<p>Pattern: <input type="text" id="findPattern0" value=""></p>
<p>Hamming distance: <input type="number" id="findPattern1" value="0"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="frameSyncConfig" class="opsConfigHidden">
<p>Frame Sync</p>
<p>Finds a sync pattern and aligns the frame, pads the frame so that all frames appear at a fixed width.</p>
<p>Sync Pattern: <input type="text" id="frameSync0" value=""></p>
<p>Hamming distance: <input type="number" id="frameSync1" value="0"></p>
<p>Frame Width: <input type="number" id="frameSync2" value="256"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="applyDeltaConfig" class="opsConfigHidden">
<p>Apply Delta</p>
<p>Used for removing differential encoding. This function takes a bit, compares it with another bit, then returns the result. For example 110 becomes 01, the "delta" between 1 and 1 being 0 and the "delta" between 1 and 0 being 1.</p>Changing the "offset" changes how many bits between delta comparisons. This allows for the delta to be applied down a column for example. At a width of 256, to apply a delta down each column, use an offset of 256.
<p>Offset: <input type="number" id="applyDelta0" value="0"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="takeSkipConfig" class="opsConfigHidden">
<p>Take Skip</p>
<p>Used to skip or change bits based on a 'command string'. Each command must be separated by a comma (,).
</p><p>Letters for the command string are: Take some bits (t), skip some bits (s), invert some bits (i), insert some zero some bits (z) or reverse some bits (r).
</p><p>The number after each letter indicates the number of bits to perform the action on. For example: t1,s2 will take one bit, then skip two bits.
</p><p>Command: <input type="text" id="takeSkip0" value="-"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="repeatBitsConfig" class="opsConfigHidden">
<p>Repeat Bits</p>
<p>Used to repeat or duplicate a set of bits a number of times. Note that all bits in the file will be repeated.
</p><p>"Chunk Size" refers to the number of bits to repeat or duplicate. Set to 0 to repeat the entire file.
</p><p>"Repeat Count" refers to the number of times to repeat before moving to the next chunk.
</p><p>Chunk Size: <input type="number" id="repeatBits0" value="0"></p>
<p>Repeat Count: <input type="number" id="repeatBits1" value="1"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="snipBitsConfig" class="opsConfigHidden">
<p>Snip Bits: Used to cut down a bit file by dropping bits from the the start and/or end of the file.
</p><p>"Start" refers to the number of bits to drop at the start of the file. 0 will keep all start bits. Negative numbers will start a number of bits from the end of the file.
</p><p>"Keep" refers to the number of bits to keep. 0 will keep all all end bits. Negative numbers will keep a number of bits from the end of a file.
</p><p>Start: <input type="number" id="snipBits0" value="0"> <button onclick="increase(&#39;snipBits0&#39;);">+</button><button onclick="decrease(&#39;snipBits0&#39;);">-</button><input type="number" id="snipBits0Increment" value="0"> <button onclick="useBitRasterScroll(&#39;snipBits0&#39;);">Use Bitraster Scroll</button> </p>
<p>Keep: <input type="number" id="snipBits1" value="0"> <button onclick="increase(&#39;snipBits1&#39;);">+</button><button onclick="decrease(&#39;snipBits1&#39;);">-</button><input type="number" id="snipBits1Increment" value="0"> <button onclick="useBitRasterScroll(&#39;snipBits1&#39;);">Use Bitraster Scroll</button> </p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="addBitsConfig" class="opsConfigHidden">
<p>Add Bits: Used to append bits to a bit file, at a given bit position.
</p><p>Postion 0 is the start of the file, position -1 is the end of the file. Position 1 is 1 bit from the start of the file, etc.
</p><p>Position: <input type="number" id="addBits0" value="0"> <button onclick="increase(&#39;addBits0&#39;);">+</button><button onclick="decrease(&#39;addBits0&#39;);">-</button><input type="number" id="addBits0Increment" value="0"> <button onclick="useBitRasterScroll(&#39;addBits0);">Use Bitraster Scroll</button> </p>
<p>Iterations: <input type="number" id="addBits1" value="0"></p>
<p>Bits: <input type="text" style="width: calc(100% - 3.5em);" id="addBits2" value="0"></p>
<p><button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</p></div>

<div id="feedThruScrambleConfig" class="opsConfigHidden">
<p>Feed Through Scrambler: Scrambles bits using the feed through method.</p>
<p>Described using "taps". For example: 0,1,7 creates a register of length 7, with tap points at the 0th, 1st and 7th bits. As bits move through the register, the tap points are added to create the scrambled output stream.</p>
<p>Use the "feedThruDescramble" to remove a feed through randomiser.</p>
<p>Taps: <input type="text" id="feedThruScramble0" value="0"> (First tap point should always be 0) </p>
<p>Reverse Taps:
<select id="feedThruScramble1" value="No">
<option value="No">No</option>
<option value="Yes">Yes</option>
</select>
</p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>
 
<div id="feedThruDescrambleConfig" class="opsConfigHidden">
<p>Feed Through Descrambler: Descrambles bits using the feed through method.</p>
<p>Described using "taps". For example: 0,1,7 creates a register of length 7, with tap points at the 0th, 1st and 7th bits. As bits move through the register, the tap points are added to create the scrambled output stream.</p>
<p>Taps: <input type="text" id="feedThruDescramble0" value="0"> (First tap point should always be 0) </p>
<p>Reverse Taps:
<select id="feedThruDescramble1" value="No">
<option value="No">No</option>
<option value="Yes">Yes</option>
</select>
</p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="additiveScrambleConfig" class="opsConfigHidden">
<p>Additive Scrambler: Scrambles (or descrambles) bits using the additive method.</p>
<p>Generates a pseudorandom binary stream and XORs the data against this stream.</p>
<o>Note that the reverse of this opperation is just to repeat the operation with the same settings.
<p>Taps: <input type="text" id="additiveScramble0" value="0"> (First tap point should always be 0) </p>
<p>Reverse Taps:
<select id="additiveScramble1" value="No">
<option value="No">No</option>
<option value="Yes">Yes</option>
</select>
</p>
<p>Initial Fill: <input type="text" id="additiveScramble2" value="0"> (1 = all 1s, 0 = all 0s)</p>
<p>Length: <input type="number" id="additiveScramble3" value="0"> (0 = maximal)</p>
<p>Rotation: <input type="number" id="additiveScramble4" value="0"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</o></div>

<div id="applyXORConfig" class="opsConfigHidden">
<p>applyXOR: (eXclusive OR) A Boolean logic operation. Compares two input bits and generates one output bit. If the bits are the same, the result is 0. If the bits are different, the result is 1.</p>
<p>Provide a binary string to "XOR" against and an offset. The string will then be XORed against the bit file and repeated for the entire file.
</p><p>Binary String: <input type="text" id="applyXOR0" value="0"></p>
<p>Offset: <input type="number" id="applyXOR1" value="0"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="invertBitsConfig" class="opsConfigHidden">
<p>Inverts all of the bits. Could also be achieved with XOR "1" or takeSkip "i1", however invertBits is much faster.
</p></div>


</div>
</div>
</div>


<div id="topMenu">

<div class="topMenuItem">
Width: <input type="number" id="widthInput" value="256">
</div>

<div class="topMenuItem">
Offset: <input type="number" id="offsetInput" value="0">
</div>

<div class="topMenuItem">
Scale: <input type="number" id="scaleInput" value="2">
</div>

<div class="topMenuItem">
Column: <input type="text" id="cursorColumn" value="0">
</div>

<div class="topMenuItem">
Row: <input type="text" id="cursorRow" value="0">
</div>

<div class="topMenuItem" style="border: none; ">
Bit: <input type="text" id="cursorBit" value="0">
</div>

</div>

<div id="bitRasterOuter">
<div id="bitRasterInner">
<div id="outputSpacer" style="width: 512px; height: 82px;"></div>
<canvas id="output" width="1878" height="855" style="border: 0px; position: absolute; z-index: 0; top: 113px; left: 21px; " onmousemove="getBitLocation(event)"></canvas>
</div>
</div>

</div>

<script>
var audioMotion = null
</script>

<script src="math.js" type="text/javascript"></script>

<script type="module">
import AudioMotionAnalyzer from 'https://cdn.skypack.dev/audiomotion-analyzer?min';
var displaySpecanButton = document.getElementById('displaySpecanButton')
displaySpecanButton.onclick = createSpecAn
var source = document.getElementById('audio');


function createSpecAn() {
audioMotion = new AudioMotionAnalyzer(
  document.getElementById('specanContainer'),
  {
    source: source,
    height: window.innerHeight - 50,
    mode: 10,
    barSpace: 0,
    ledBars: false,
    frequencyScale: 'linear',
    maxFreq: 4000,
    height: 150,
    smoothing: 0,
    colorMode: 'gradient',
    gradient: 'prism',
    fftSize: 8192,
    showBgColor: false,
    lineWidth: 1,
    fillAlpha: 0.5
  }
);
}


</script>

<script>


var colorMode = 'dark';
var styleDocs = [];
var bitRasterBg = getComputedStyle(document.body).getPropertyValue('--bitRasterBg');
var lineColor = getComputedStyle(document.body).getPropertyValue('--textColor');
function toggleColorMode() {
	styleDocs = [document.documentElement.style];
	if (colorMode == 'dark') { UI_lightMode(); return null; }
	if (colorMode == 'light') { UI_darkMode(); return null; }
}

function UI_lightMode () {
	colorMode = 'light'
	styleDocs.forEach( function(style) {
	style.setProperty('--background', 'var(--backgroundLight)');
	style.setProperty('--midground', 'var(--midgroundLight)');
	style.setProperty('--borderColor', 'var(--borderColorLight)');
	style.setProperty('--buttonbg', 'var(--buttonbgLight)');
	style.setProperty('--entrybg', 'var(--entrybgLight)');
	style.setProperty('--buttonbgHover', 'var(--buttonbgHoverLight)');
	style.setProperty('--buttonbgSelected', 'var(--buttonbgSelectedLight)');
	style.setProperty('--buttonfgSelected', 'var(--buttonfgSelectedLight)');
	style.setProperty('--textColor', 'var(--textColorLight)');
	style.setProperty('--tableHeadColor', 'var(--tableHeadColorLight)');
	style.setProperty('--tableHighlightColor', 'var(--tableHighlightColorLight)');
	style.setProperty('--tableHighlightColor2', 'var(--tableHighlightColorLight2)');
	style.setProperty('--cellColor', 'var(--cellColorLight)');
	style.setProperty('--cellBorder', 'var(--cellBorderLight)');
	style.setProperty('--cellBorderStrong', 'var(--cellBorderStrongLight)');
	style.setProperty('--shadowColor', 'var(--shadowColorLight)');
	style.setProperty('--tableTopLeft', 'var(--tableTopLeftLight)');
	style.setProperty('--bitRasterBg', 'var(--bitRasterBgLight)');
	});
	bitRasterBg = getComputedStyle(document.body).getPropertyValue('--bitRasterBg');
	lineColor = getComputedStyle(document.body).getPropertyValue('--textColor');
	updateBitRaster();
}

function UI_darkMode () {
	colorMode = 'dark';
	styleDocs.forEach( function(style) {
	style.setProperty('--background', 'var(--backgroundDark)');
	style.setProperty('--midground', 'var(--midgroundDark)');
	style.setProperty('--borderColor', 'var(--borderColorDark)');
	style.setProperty('--buttonbg', 'var(--buttonbgDark)');
	style.setProperty('--entrybg', 'var(--entrybgDark)');
	style.setProperty('--buttonbgHover', 'var(--buttonbgHoverDark)');
	style.setProperty('--buttonbgSelected', 'var(--buttonbgSelectedDark)');
	style.setProperty('--buttonfgSelected', 'var(--buttonfgSelectedDark)');
	style.setProperty('--textColor', 'var(--textColorDark)');
	style.setProperty('--tableHeadColor', 'var(--tableHeadColorDark)');
	style.setProperty('--tableHighlightColor', 'var(--tableHighlightColorDark)');
	style.setProperty('--tableHighlightColor2', 'var(--tableHighlightColorDark2)');
	style.setProperty('--cellColor', 'var(--cellColorDark)');
	style.setProperty('--cellBorder', 'var(--cellBorderDark)');
	style.setProperty('--cellBorderStrong', 'var(--cellBorderStrongDark)');
	style.setProperty('--shadowColor', 'var(--shadowColorDark)');
	style.setProperty('--tableTopLeft', 'var(--tableTopLeftDark)');
	style.setProperty('--bitRasterBg', 'var(--bitRasterBgDark)');
	});
	bitRasterBg = getComputedStyle(document.body).getPropertyValue('--bitRasterBg');
	lineColor = getComputedStyle(document.body).getPropertyValue('--textColor');
	updateBitRaster();
}


String.prototype.replaceAll = function(str1, str2, ignore) 
{
    return this.replace(new RegExp(str1.replace(/([\/\,\!\\\^\$\{\}\[\]\(\)\.\*\+\?\|\<\>\-\&])/g,"\\$&"),(ignore?"gi":"g")),(typeof(str2)=="string")?str2.replace(/\$/g,"$$$$"):str2);
} 

function ByteReader( bytedata ) {
this._data = bytedata || "";
this._offset = 0;
}

ByteReader.prototype = {

	constructor: ByteReader,

	EOF: function(){
	return this._offset >= this._data.length;
	},

	tellSize: function(){
	return this._data.length;
	},

	seekTo: function( offset ){
	this._offset = offset;
	return this;
	},

	rewind: function() {
	this._offset = 0;
	return this;
	},

	readBytes: function( bytes ) {
	var s = this._data.substr( this._offset, bytes );
	this._offset += bytes;
	return s;
	},

	setByteStream: function( data ) {

		if( typeof data != "string" )
		throw new TypeError( typeof data + " must be string" );

	this._data = data;
	this._offset = 0;
	return this;
	},

	readDouble: function( littleEndian ) {
	var s = this.readBytes( 8 );
	var pow = Math.pow, sign, exponent, fraction;

		if( littleEndian )
		s = s.split("").reverse().join("");

	sign =  ( s.charCodeAt(0) & 0x80 ) >> 7;
	exponent =  ( ( s.charCodeAt(0) & 0x7F ) << 4 ) | ( ( s.charCodeAt(1) & 0xF0 ) >> 4 );
	fraction =  ( ( s.charCodeAt(1) & 0x0F ) * pow(2, 48) ) +
			s.charCodeAt(2) * pow( 2, 40 ) +
			s.charCodeAt(3) * pow( 2, 32 ) +
			( ( s.charCodeAt(4) & 0xFF ) << 24 ) +
			( ( s.charCodeAt(5) & 0xFF ) << 16 ) +
			( ( s.charCodeAt(6) & 0xFF ) << 8  ) +
			s.charCodeAt(7);

	sign = pow( -1, sign );

		if( exponent === 2047 ) {
			if( fraction !== 0)
			return Number.NaN;

			else if( sign < 0 )
			return -Infinity;

			else
			return Infinity;
		}
		else if( exponent > 0 )
		return sign * Math.pow( 2, exponent - 1023 ) * ( fraction / 0x10000000000000 + 1 );


		else if ( fraction !== 0 )
		return sign * Math.pow( 2, -1022 ) * ( fraction / 0x10000000000000 );


		else 
		return 0;

	},

	readSingle: function( littleEndian ) {
	var s = this.readBytes( 4 )
	var sign, exponent, fraction;

		if( littleEndian )
		s = s.split("").reverse().join("");

	sign =  ( s.charCodeAt(0) & 0x80 ) >> 7;
	exponent =  ( ( s.charCodeAt(0) & 0x7F ) << 1 )  | ( ( s.charCodeAt(1) & 0x80 ) >> 7 );
	fraction =  ( ( s.charCodeAt(1) & 0x7F ) << 16 ) |
			( ( s.charCodeAt(2) & 0xFF ) << 8 )  |
			( s.charCodeAt(3) & 0xFF );

	sign = Math.pow( -1, sign );

		if( exponent === 255 ) {

			if( fraction !== 0 )
			return Number.Nan;

			else if( sign < 0 )
			return -Infinity;

			else
			return Infinity;
		}
		else if( exponent > 0 )
		return sign * Math.pow(2, exponent - 127) * ( fraction / 0x800000 + 1 );

		else if ( fraction !== 0 )
		return sign *  Math.pow(2, -126) * ( fraction / 0x800000 );

		else
		return 0;

	},

	readSByte: function() {
	var s = this.readBytes( 1 ).charCodeAt( 0 ) & 0xFF;
	return ( s ^ 0x80 ) - 0x80;
	},

	readUByte: function() {
	return this.readBytes( 1 ).charCodeAt( 0 ) & 0xFF;
	},
	
	readUBits: function() {
	return ('00000000'+ ( this.readBytes( 1 ).charCodeAt( 0 ) & 0xFF).toString(2)).slice(-8);
	},

	readUShort: function( littleEndian ) {
	var s = this.readBytes( 2 );

		if( littleEndian )
		return ( s.charCodeAt( 0 ) & 0xFF ) |
		( ( s.charCodeAt( 1 ) & 0xFF) << 8 );

		else
		return ( s.charCodeAt( 1 ) & 0xFF ) |
		( ( s.charCodeAt( 0 ) & 0xFF) << 8 );
	},

	readULong: function( littleEndian ) {
	var s = this.readBytes( 4 ), r;

		if( littleEndian ) 
		r = ( s.charCodeAt( 0 ) & 0xFF )        |
		( ( s.charCodeAt( 1 ) & 0xFF ) << 8 )   |
		( ( s.charCodeAt( 2 ) & 0xFF ) << 16 )  |
		( ( s.charCodeAt( 3 ) & 0xFF ) << 24 );

		else
		r = ( s.charCodeAt( 3 ) & 0xFF )        |
		( ( s.charCodeAt( 2 ) & 0xFF ) << 8 )   |
		( ( s.charCodeAt( 1 ) & 0xFF ) << 16 )  |
		( ( s.charCodeAt( 0 ) & 0xFF ) << 24 );

		if ( r & 0x80000000 )
		r = ( r & 0x7FFFFFFF ) + 0x80000000;

	return r;
	},

	readSShort: function( littleEndian ){
	var s = this.readBytes( 2 ), r;

		if( littleEndian )
		r = ( s.charCodeAt( 0 ) & 0xFF ) |
		( ( s.charCodeAt( 1 ) & 0xFF) << 8 );

		else
		r = ( s.charCodeAt( 1 ) & 0xFF ) |
		( ( s.charCodeAt( 0 ) & 0xFF) << 8 );

	return ( r ^ 0x8000 ) - 0x8000;
	},

	readSLong: function( littleEndian ){
	var s = this.readBytes( 4 ), r;

		if( littleEndian ) 
		return ( s.charCodeAt( 0 ) & 0xFF ) |
		( ( s.charCodeAt( 1 ) & 0xFF ) << 8 )   |
		( ( s.charCodeAt( 2 ) & 0xFF ) << 16 )  |
		( ( s.charCodeAt( 3 ) & 0xFF ) << 24 );

		else
		return ( s.charCodeAt( 3 ) & 0xFF ) |
		( ( s.charCodeAt( 2 ) & 0xFF ) << 8 )   |
		( ( s.charCodeAt( 1 ) & 0xFF ) << 16 )  |
		( ( s.charCodeAt( 0 ) & 0xFF ) << 24 );

	}


};

const status = document.getElementById('status');
const output = document.getElementById('output');
const spacer = document.getElementById('outputSpacer');
const biasView = document.getElementById('biasView');
const widthInput = document.getElementById('widthInput');
const scaleInput = document.getElementById('scaleInput');
const fileSelector = document.getElementById('fileSelector')
const offsetInput = document.getElementById('offsetInput');
const positionOutput = document.getElementById('position');
const operationsListHTML = document.getElementById('operationsList');
var operationsList = [];

var bits = Array(10000).fill(0);
additiveScramble("0,1,7","No","1","0","0");
var bitsNoOp = [...bits];

var mouseX = 0;
var mouseY = 0;
document.onmousemove = function(event) {
        mouseX = event.pageX;
        mouseY = event.pageY;
    };


document.addEventListener("wheel", function(e) {
  var bounds = output.getBoundingClientRect()
  if (mouseY > bounds['top'] && mouseY < bounds['bottom'] && mouseX > bounds['left'] && mouseX < bounds['right']) {
		if (event.shiftKey) {
			output.parentElement.scrollBy(e.deltaY/10, 0);
				} else {
			output.parentElement.scrollBy(0, e.deltaY/10);
				}
		}
});

output.parentElement.onscroll = function (e) {  
	updateBitRaster();
};


function makeInt(item) {
	return parseInt(item);
}

function generateBytes() {
	var bytes = new Uint8Array(bits.length / 8);
	var byte = 0
	for (let i = 0; i < bits.length; i+=8) {
		bytes[byte] = parseInt( bits.slice(i, i+8).join(''), 2);
		byte++;
	}

	return bytes;
}
 
function generateOutput() {
	list = document.getElementById("outputList");

	while (list.hasChildNodes()) {
		list.removeChild(list.firstChild);
	}

	var d = new Date();
	let time = d.getTime();

	let link = document.createElement('a');
	link.innerHTML = time + '_output.bit';
	link.download = time + '_output.bit';
	link.style = 'color: white;'
	let bytes = generateBytes();
	let  blob = new Blob([bytes], { type: 'application/octet-stream' });
	link.href = URL.createObjectURL(blob);
	list.appendChild(link);
}
 
function arraysEqual(a, b) {
	if (a === b) return true;
	if (a == null || b == null) return false;
	if (a.length !== b.length) return false;

	for (var i = 0; i < a.length; ++i) {
		if (a[i] !== b[i]) return false;
		}
	return true;
}

function applyXOR(binaryString, offset) {
	binaryString = binaryString.split('').map(makeInt);
	offset = parseInt(offset);
	
	if (offset < 0) {offset = binaryString.length - (offset % binaryString.length);}	
	newBits = new Array(bits.length);
	
	for (let i = 0; i < bits.length; i++) {
		newBits[i] = (bits[i] + binaryString[(i+offset) % binaryString.length]) % 2;
	}
	
	bits = newBits;
	delete newBits;
}

function additiveScramble(taps, reversed, fill, length, rotation) {
	taps = taps.split(',').map(makeInt);
	var tapsRev = [];
	var lastTap = taps.slice(-1)[0];

	tapsRev.push(taps[0]);
	for (let i = 1; i < taps.length - 1; i++) {
		tapsRev.push(lastTap - taps[i]);
	}
	tapsRev.push(lastTap);

	if (reversed == 'No') {taps = tapsRev;}
	
	var register = fill.repeat(lastTap).split('').slice(0, lastTap).map(makeInt);
	var scramble = [];
	
	length = parseInt(length);
	var bit = 0;
	var initial = register.join('');
	
	if (length == 0) {
		
		do {
			bit = 0;

			for (let x = 1; x < taps.length; x++) {
				bit = bit + register[taps[x]-1];
			}

			bit = bit % 2;
			register.unshift(bit);
			register.pop();
			scramble.push(bit);
		}
		while (initial != register.join(''));
	
	} else {
	
		do {
			bit = 0;

			for (let x = 1; x < taps.length; x++) {
				bit = bit + register[taps[x]-1];
			}

			bit = bit % 2;
			register.unshift(bit);
			register.pop();
			scramble.push(bit);
		}
		while (scramble.length < length);
	
	}
	
	rotation = parseInt(rotation);
	if (rotation < 0) {rotation = output.length - (rotation % output.length);}	
	
	for (let i = 0; i < bits.length; i++) {
		bits[i] = (bits[i] + scramble[(i+rotation) % scramble.length]) % 2;
	}
	
}

function hammingDistance(bits1, bits2) {
	var distance = 0
	for (let x = 0; x < bits1.length; x++) {
		distance += (bits1[x] + bits2[x]) % 2;
	}
	return distance
}

function amplify(gain) {
	
	var newBits = new Array()
	var sample = 0
	for (let x = 0; x<bits.length; x+=8 ) {
		sample = Math.round( parseInt(bits.slice(x,x+8).join(''),2) * gain )
		sample = ('0000000' + sample.toString(2)).split('').slice(-8).map(makeInt)
		newBits.push( ...sample )
	}
	
	bits = newBits
	delete newBits
	
}

function validateCoefs(coefs) {
	var validCoefs = new Array()
	coefs = coefs.split(',')
	for (let x = 0; x < coefs.length; x++) {
		let coef = parseFloat(coefs[x])
		if (isNaN(coef) == false) { validCoefs.push( coef ) }
	}
	return validCoefs
}

function firFilter(coefs) {
	coefs = validateCoefs(coefs)
	if (coefs.length == 0) { return null }

	var newBits = new Array()
	var newSamples = new Array()
	var samples = new Array(coefs.length).fill(0)
	
	for (let x = 0; x < bits.length; x+=8) {
		sample = parseInt(bits.slice(x,x+8).join(''),2)
		samples.push(sample)
	}
	
	var acc = 0
	var max = 0
	for (let x = coefs.length; x < samples.length; x++) {
		acc = 0
		for (let y = 0; y < coefs.length; y++) {
			acc += (samples[x-y]-127.0)/127.0 * coefs[y]
		}
		newSamples.push( Math.round( 127+ (acc*127) ) )
	}
	
	for (let x = 0	; x < newSamples.length; x++) {
		newBits.push( ...('0000000' + newSamples[x].toString(2)).split('').slice(-8).map(makeInt) )
	}
	
	bits = newBits
	delete newBits

} 

function addNoise(noise) {
	
	var newBits = new Array()

	for (let x = 0; x<bits.length; x+=8 ) {
		let sample = (parseInt(bits.slice(x,x+8).join(''),2) - 127) / 127
		sample = Math.round( 127 + (((sample * 100 + (Math.random()-0.5) * noise) / 200) * 127) )
		sample = ('0000000' + sample.toString(2)).split('').slice(-8).map(makeInt)
		newBits.push( ...sample )
	}
	
	bits = newBits
	delete newBits
}

function frequencyShift(frequency) {
	var period = 8000 / frequency
	var newBits = new Array()

	for (let x = 0; x<bits.length-8; x+=8 ) {
		let sampleSin = (parseInt(bits.slice(x,x+8).join(''),2) - 127) / 127
		let sampleCos = (parseInt(bits.slice(x+8,x+16).join(''),2) - 127) / 127
		let complexS = math.complex(sampleSin, sampleCos)
		let carrierSin = Math.sin(2.0 * Math.PI * (x/8) / period)
		let carrierCos = Math.cos(2.0 * Math.PI * (x/8) / period)
		let complexC = math.complex(carrierSin, carrierCos)
		let sample = math.multiply(complexS, complexC)
		sample = sample.re
		sample = Math.round( 127 + (sample * 127))
		sample = ('0000000' + sample.toString(2)).split('').slice(-8).map(makeInt)
		newBits.push( ...sample )
	}
	
	bits = newBits
	delete newBits
}


function sinePCM(frequency, duration, phase=1, amplitude=60) {

	var period = 8000 / frequency
	var duration = parseInt(duration * 8000)
	
	if(frequency == 0) {
		samples = '000000'.repeat(duration)
		return samples.split('').map(makeInt)
	}

	var newBits = new Array()
	var sample = 0
	
	for (let j = (period*phase); j < duration + (period*phase); ++j) { 
		sample = Math.round( Math.random() + 127 + (amplitude * (Math.sin(2.0 * Math.PI * j / period))));
		sample = ('0000000' + sample.toString(2)).split('').slice(-8).map(makeInt)
		newBits.push( ...sample )
    }
    
    return newBits
}

function fskModulate(lowF, highF, rate) {
	var lowF = parseInt(lowF)
	var highF = parseInt(highF)
	var rate = parseInt(rate)

	var newBits = new Array()
	var low = sinePCM(lowF, 1/rate, 1, 60)
	var high = sinePCM(highF, 1/rate, 1, 60)
	var nothing = sinePCM(1, 1/rate, 1, 0)
	var length = bits.length ;
	if (length/rate > 130) { length = parseInt(130 * rate)}
	
	for (let x = 0; x < length; x++) {
		if (bits.slice(x,x+24).join('') == '000000000000000000000000') { 
			newBits.push( ...nothing )
		} else {
	
			if (bits[x] == 1) {newBits.push( ...high )} 
			else {newBits.push( ...low )}
			
		}
	}
	
	bits = newBits
	delete newBits
}

function bpskModulate(frequency, rate) {
	var frequency = parseInt(frequency)
	var rate = parseInt(rate)

	var newBits = new Array()
	var low = sinePCM(frequency, 1/rate, 0, 60)
	var high = sinePCM(frequency, 1/rate, 0.5, 60)
	var nothing = sinePCM(frequency, 1/rate, 0, 0)
	var length = bits.length;
	if (length/rate > 130) { length = parseInt(130 * rate) }
	
	for (let x = 0; x < length; x++) {
		if (bits.slice(x,x+24).join('') == '000000000000000000000000') { 
			newBits.push( ...nothing )
		} else {
	
			if (bits[x] == 1) {newBits.push( ...high )} 
			else {newBits.push( ...low )}
			
		}
	}
	
	bits = newBits
	delete newBits
}

function spread(spreadingCode) {
	var newBits = new Array()
	spreadingCode = spreadingCode.split('').map(makeInt)
	var invertedCode = spreadingCode.map(invert)

	for (let x = 0; x < bits.length; x++) {
		if (bits[x] == 1) {newBits.push( ...spreadingCode )} 
		else {newBits.push( ...invertedCode )}
	}
	
	bits = newBits
	delete newBits
}


function qpskModulate(frequency, rate) {
	var frequency = parseInt(frequency)
	var rate = parseInt(rate)

	var newBits = new Array()
	var bits2symbol = {}
	
	bits2symbol['00'] = sinePCM( frequency, 1/rate, 0, 60 )
	bits2symbol['01'] = sinePCM( frequency, 1/rate, 0.25, 60 )
	bits2symbol['10'] = sinePCM( frequency, 1/rate, 0.5, 60 )
	bits2symbol['11'] = sinePCM( frequency, 1/rate, 0.75, 60 )
	bits2symbol['__'] = sinePCM( frequency, 1/rate, 0, 0 )
	
	console.log(bits2symbol)
	
	var length = bits.length
	
	if (length/rate > 130) { length = parseInt(130 * rate) }
	
	for (let x = 0; x < length; x+=2) {
		if (bits.slice(x,x+23).join('') == '00000000000000000000000') { 
			newBits.push( ...bits2symbol['__'] )
		} else {
			newBits.push( ...bits2symbol[ bits.slice(x,x+2).join('') ] )
		}
	}
	
	bits = newBits
	delete newBits
}

function askModulate(frequency, rate, ammount) {
	var frequency = parseInt(frequency)
	var rate = parseInt(rate)

	var newBits = new Array()
	var low = sinePCM(frequency, 1/rate, 1, 60 - (60*(ammount/100)))
	var high = sinePCM(frequency, 1/rate, 1, 60)
	var nothing = sinePCM(frequency, 1/rate, 1, 0)
	var length = bits.length;
	if (length/rate > 130) { length = parseInt(130 * rate) }
	
	for (let x = 0; x < length; x++) {
		if (bits.slice(x,x+24).join('') == '000000000000000000000000') { 
			newBits.push( ...nothing )
		} else {
	
			if (bits[x] == 1) {newBits.push( ...high )} 
			else {newBits.push( ...low )}
			
		}
	}
	
	bits = newBits
	delete newBits
}

function findPattern(pattern, distance) {
	if (pattern == '0') {return null}
	pattern = pattern.split('').map(makeInt)
	
	var matches = new Array();
	distance = parseInt(distance)
	
	for (let x = 0; x < bits.length; x++) {
		if ( hammingDistance(bits.slice(x,x+pattern.length), pattern) <= distance ) {
			matches.push(x)
		}
	}
	
	var newBits = new Array(bits.length).fill(0)
	
	for (let a = 0; a < matches.length; a++) {
		for (let x = 0; x < pattern.length; x++) {
			newBits[matches[a]+x] = 1
		}
	}
	
	bits = newBits
	delete newBits
}

function averageBits(start, stop, bias=0.5) {
	var total = 0;
	
	for (let x = start; x < stop; x++) {
		total += bits[x]
	}
	
	if (total == 0) { return 0 }
	if (total / (stop-start) < bias) { return 0 }
	return 1

}

function mergeBits(length, bias) {
	length = parseInt(length)
	bias = parseInt(bias) / 100.0
	console.log(bias)
	var start = 0
	var newBits = new Array()
	
	for (let x = start; x < bits.length-length;) {
		newBits.push( averageBits(x,x+length, bias) )
		x+=length
	}
	
	bits = newBits
	delete newBits
}

function frameSync(pattern, distance, frameWidth) {
	if (pattern == '0') {return null}
	pattern = pattern.split('').map(makeInt)

	var frameStarts = new Array();
	distance = parseInt(distance)
	frameWidth = parseInt(frameWidth)
	
	for (let x = 0; x < bits.length; x++) {
		if ( hammingDistance(bits.slice(x,x+pattern.length), pattern) <= distance ) {
			frameStarts.push(x)
		}
	}
	
	console.log( frameStarts );
	
	var newBits = new Array();
	var frameLen = 0;
	
	for (let a = 0; a < frameStarts.length; a++) {
		if ( a == frameStarts.length - 1 ) { frameLen = bits.length - frameStarts[a] }
		else { frameLen =  frameStarts[a+1] - frameStarts[a] } 
		console.log(frameLen)
		newBits.push( ...bits.slice(frameStarts[a], frameStarts[a]+frameLen) )
		if (frameLen < frameWidth) { newBits.push( ...(new Array(frameWidth - frameLen).fill(0)) ) }
	}
	
	bits = newBits;
	delete newBits;

}

function feedThruScramble(taps, reversed) {
	taps = taps.split(',').map(makeInt);
	var tapsRev = [];
	var lastTap = taps.slice(-1)[0];

	tapsRev.push(taps[0]);
	for (let i = 1; i < taps.length - 1; i++) {
		tapsRev.push(lastTap - taps[i]);
	}
	tapsRev.push(lastTap);

	if (reversed == 'No') {taps = tapsRev;}

	register = new Array(lastTap).fill(0);
	newBits = new Array(bits.lenght);
	
	for (let a = 0; a < taps.length; a++) {
		taps[a] = Math.abs(taps[a] - lastTap);
	}
   
	var bit = 0;
	var offset = 0;
	for (let i = 0; i < bits.length; i++) {
		bit = bits[i];

		for (let x = 1; x < taps.length; x++) {
			bit = bit + register[taps[x] + offset];
		}

		bit = bit % 2;
		register.push(bit);
		newBits[i] = bit;
		offset++;
	}

	bits = newBits;
	delete newBits;
}
 
function feedThruDescramble(taps, reversed) {
	taps = taps.split(',').map(makeInt);
	var tapsRev = [];
	var lastTap = taps.slice(-1)[0];

	tapsRev.push(taps[0]);
	for (let i = 1; i < taps.length - 1; i++) {
		tapsRev.push(lastTap - taps[i]);
	}
	tapsRev.push(lastTap);

	if (reversed == 'No') {taps = tapsRev;}

	register = new Array(lastTap).fill(0);
	newBits = new Array(bits.lenght);
	
	for (let a = 0; a < taps.length; a++) {
		taps[a] = Math.abs(taps[a] - lastTap);
	}
	
	var bit = 0;
	var offset = 0;
	for (let i = 0; i < bits.length; i++) {
		bit = bits[i];
		register.push(bit);
		offset++;

		for (let x = 1; x < taps.length; x++) {
			bit = bit + register[taps[x] + offset -1];
		}

		bit = bit % 2;
		newBits[i] = bit;
		
	}

	bits = newBits;
	delete newBits;
}


function updateAsciiView() {
	var width = parseInt(widthInput.value);
	var ascii = [];
	var line = [];
	var x = 0;
	
	maxBit = bits.length;
	if ((width * 40)+startBit < maxBit) {maxBit = (width * 20)+startBit;}
	if (bits.length < 100000) { maxBit = bits.length; }
	
	for (let i = startBit; i < maxBit; i+=8) {
		line.push( String.fromCharCode( parseInt( bits.slice(i, i+8).join(''), 2) ) );
		x+=1;
		if (x == width) {
			ascii.push(line.join(''));
			x = 0;
			line = [];
		}
	}
	ascii.push(line.join(''));
	document.getElementById('asciiViewOutput').value = ascii.join('');

}


function updateHexView() {
	var width = parseInt(widthInput.value);
	var hex = [];
	var line = [];
	var x = 0;
	var leftOver = 0;
	
	maxBit = bits.length;
	if ((width * 20)+startBit < maxBit) {maxBit = (width * 20)+startBit;}
	if (bits.length < 100000) { maxBit = bits.length; }
	
	for (let i = startBit; i < maxBit;) {
		line.push( ('00' + parseInt(bits.slice(i, i+8).join(''), 2).toString(16)).slice(-2) );
		i+=8;
		x+=8;
		if (x == width) {
			hex.push(line.join(' '));
			x = 0;
			line = [];
		}
		
		if (x+8 >= width) {
			leftOver = width - x;
			line.push( ('00' + parseInt(bits.slice(i, i+leftOver).join(''), 2).toString(16)).slice(-2) );
			hex.push(line.join(' '));
			i += leftOver;
			x = 0;
			line = [];
		}
		
	}
	hex.push(line.join(' '));
	document.getElementById('hexViewOutput').innerHTML = hex.join('\n');

}

function byteSpace(binary) {
	//binary is array of strings
	binary = binary.map( function(row) {
		var newRow = []
		for (var x=0; x<row.length; x+=8) {
			newRow.push(row.substring(x, x+8));
			newRow.push(' ');
		}
		
		return newRow.join('');
	})
	return binary;
}

binaryViewLimit = 20;
function updateBinaryView() {
	var viewType = document.getElementById("binaryViewType").value;
	var spacing = document.getElementById("binaryViewSpacing").value;
	
	var width = parseInt(widthInput.value);
	var binary = [];
	
	maxBit = bits.length;
	if ((width * binaryViewLimit)+startBit < maxBit) {maxBit = (width * binaryViewLimit)+startBit;}
	if (bits.length < 100000) { maxBit = bits.length; }
	
	for (var i = startBit; i < maxBit;) {
		binary.push(bits.slice(i, i+width).join(''));
		i += width;
	}
	
	
	if (spacing == 'bit spaced') { binary = binary.join('\n'); }
	if (spacing == 'byte spaced') { binary = byteSpace(binary).join('\n'); };
	
	if (viewType == 'standard view') { } // do nothing
	if (viewType == '.x view') { binary = binary.replaceAll('1','X').replaceAll('0','.').replaceAll(' ', '|'); }

	document.getElementById('binaryViewOutput').innerHTML = binary;
}

function loadFullBinaryView() {
	var initialBinaryView = binaryViewLimit + 0;
	var initialStartBit = startBit + 0;
	binaryViewLimit = bits.length / parseInt(widthInput.value);
	startBit = 0;
	updateBinaryView();
	binaryViewLimit = initialBinaryView;
	startBit = initialStartBit;
}



function addOperation(operation, args) {
	operationsList.push([operation, args]);
	operationsListHTML.innerHTML = "";
	operationsList.forEach(addToOpsListDisplay);
	runOperations();
}

function closeConfigureOperation() {
	document.getElementsByClassName('opsConfig')[0].className = 'opsConfigHidden';
}

var openOpsConfig = null;

function configureOperation(index) {
	if (document.getElementsByClassName('opsConfig').length > 0) {
		closeConfigureOperation();
	}
	
	for (let a=0; a < operationsList.length; a++) {
		document.getElementById('configureButton' + a).style.backgroundColor = '';
		document.getElementById('configureButton' + a).style.color = '';
		
	}
	
	document.getElementById('configureButton' + index).style.backgroundColor = 'var(--buttonbgSelected)';
	document.getElementById('configureButton' + index).style.color = 'var(--buttonfgSelected)';
	

	var type = operationsList[index][0];
	var args = operationsList[index][1];
	var configObject = document.getElementById(type + 'Config');
	configObject.className = 'opsConfig';
	
	for (let i=0; i < args.length; i++) {
		document.getElementById(type + i).value = args[i];
	}
	
	openOpsConfig = index;
}

function updateOperation() {
	var type = operationsList[openOpsConfig][0]
	var args = operationsList[openOpsConfig][1]
	
	for (let i = 0; i < args.length; i++) {
		args[i] = document.getElementById(type+i).value;
	}
	operationsList[openOpsConfig] = [type, args];
	runOperations();
	
}

function addToOpsListDisplay(item, index) {
	operationsListHTML.innerHTML +=
	"<button id='configureButton" + index  + "' style='width: calc(85% - 4px);'" +
	"onclick='configureOperation(" + index + ")'" +
	">" + item[0] + "</button>" +
	"<button style='width: calc(10% - 4px); text-align: center; padding-left: 0px; padding-right: 0px; margin-left: 1px;'" + 
	"onclick='removeOperation(" + index + ")'" +
	">X</button>";
}

function removeOperation(index) {
	if (document.getElementsByClassName('opsConfig').length > 0) {
		closeConfigureOperation();
	}
	operationsList.splice(index, 1);
	operationsListHTML.innerHTML = "";
	operationsList.forEach(addToOpsListDisplay);
	runOperations();
}

function runOperations() {
	bits = [...bitsNoOp]
	operationsList.forEach(runOperation);
	updateBitRaster();
}

function runOperation(operation) {
	var operationName = operation[0];
	var operationArguments = operation[1];
	var command = operationName + '("' + operationArguments.join('","') + '");'
	command = command.split('\n').join('')
	console.log(command);
	eval(command);
}

function applyDelta(offset) {
	newBits = new Array(bits.length + offset.length).fill(0);
	for (let i = offset.length; i < bits.length; i++) { 
		newBits[i] = (bits[i] + bits[i+parseInt(offset)]) % 2;
	}
	bits = newBits;
	delete newBits;
}

function invert(bit, index) {
	return (bit + 1) % 2;
}

function invertBits() {
	bits = bits.map(invert);
}


function repeatBits(chunkSize, timesToRepeat) {
	chunkSize = parseInt(chunkSize);
	timesToRepeat = parseInt(timesToRepeat);
	
	if (chunkSize == 0) {chunkSize = bits.length;}

	if (chunkSize == bits.length) {
		bits = bits.join('').repeat(timesToRepeat+1).split('');
	} else {
	
		newBits = new Array();
		
		for (let i = 0; i < bits.length;) {
			for (let x=0; x < timesToRepeat+1; x++) {
				newBits.push( ...bits.slice(i,i+chunkSize) );
			}
			i += chunkSize;
		}
		bits = newBits;
		delete newBits;
	}
}


function addBits(start, iterations, bitsToAdd) {
	start = parseInt(start);
	bitsToAdd = bitsToAdd.repeat(iterations);
	bitsToAdd = bitsToAdd.split('').map(makeInt);

	if (start > -1) {
		newBits = bits.slice(0, start);
		newBits = newBits.concat(bitsToAdd);
		newBits.push( ...bits.slice(start) );
	} else {
		start = start * -1
		var revBits = bits;
		revBits.reverse();
		bitsToAdd.reverse();
		
		newBits = revBits.slice(0, start-1);
		newBits.push( ...bitsToAdd );
		newBits.push( ...revBits.slice(start-1) );
		newBits.reverse();
	}
	
	bits = newBits;
	delete newBits;
}

function snipBits(start, keep) {
	start = parseInt(start);
	keep = parseInt(keep);
	
	if (keep == 0) {
		bits = bits.slice(start);
	} else if (keep < 0) {
		bits = bits.slice(start, keep);
	} else {
		bits = bits.slice(start, start+keep);
	}
}

function increase(field) {
	document.getElementById(field).value = parseInt(document.getElementById(field).value) + parseInt(document.getElementById(field + 'Increment').value);
	updateOperation();
}

function decrease(field) {
	document.getElementById(field).value = parseInt(document.getElementById(field).value) - parseInt(document.getElementById(field + 'Increment').value);
	updateOperation()
}

function useBitRasterScroll(field) {
	var position = parseInt((document.getElementById('bitRasterInner').scrollTop / document.getElementById('bitRasterInner').scrollHeight) * bits.length);
	document.getElementById(field).value = position;
}


function takeSkip(commandString) {
	var takeSkipBits = [];
	var takeSkipCommands = [];
   
   
	var commandPositions = []
	for (let a = 0; a < commandString.length; a++) {
		if (['t','z','s','i','o','r'].includes(commandString.slice(a,a+1))) {
				commandPositions.push(a);
		}
	}
	commandPositions.push(commandString.length);
   
	var amount = 0;
	for (let b = 0; b < commandPositions.length-1; b++) {
		amount = parseInt(commandString.slice(commandPositions[b]+1, commandPositions[b+1]));
		takeSkipCommands.push( [commandString.slice(commandPositions[b],commandPositions[b]+1), amount] );
	}
   
	var c = [];
	var count = 0

	for (let i = 0; i < bits.length;) {
		c = takeSkipCommands[count % takeSkipCommands.length];

		if (c[0] == 'z') {
			takeSkipBits.push( ...Array(c[1]).fill(0) );
		} else if (c[0] == 'o') {
			takeSkipBits.push( ...Array(c[1]).fill(1) );
			count++;
		} else if (c[0] == 't') {
			takeSkipBits.push( ...bits.slice(i, i+c[1]) );
			i+=c[1];
		} else if (c[0] == 's') {
			i+=c[1];
		} else if (c[0] == 'i') {
			takeSkipBits.push( ...bits.slice(i, i+c[1]).map(invert) );
			i+=c[1];
		} else if (c[0] == 'r') {
			takeSkipBits.push( ...bits.slice(i, i+c[1]).reverse() );
			i+=c[1];
		}
		count++;
				   
	}
   
	bits = takeSkipBits;
}



function columnBias(width, checkBits) {
	var bias = 0;
	var count = 0;
	var total = 0;
	var delta = 0;
	checkBits = parseInt(checkBits);
	
	for (var i=0; i<width; i++){
		count = 0;
		total = 0;

		for (var pos = i; pos < checkBits;){
			total += bits[pos];
			pos += width;
			count += 1;
		}
		
		bias = parseFloat(total) / parseFloat(count);
		delta += Math.abs(bias - 0.5);
		
	}
	
	delta = delta / width;
	return delta / 0.5;
}

function findWidth() {
	setTimeout(clearWidthGraph, 0);
	setTimeout(runFindWidth, 200);
}

function clearWidthGraph () {
	var graph = document.getElementById("findWidthGraph");
	var overlay = document.getElementById("findWidthOverlay");
	var graphWidth = parseInt(graph.parentElement.clientWidth);
	graph.width = graphWidth;
	overlay.width = graphWidth;
	
	var ctx = graph.getContext("2d");
	var text = ctx.measureText("Testing Widths...")
	ctx.clearRect(0, 0, graph.width, graph.height);
	ctx.font = "20px 'Comic Sans MS', 'Comic Sans', cursive";
	ctx.fillStyle = "#fff";
	ctx.fillText("Testing Widths...", (graph.width/2)-text.width, graph.height/2)-text.height;
}

var pixPerResult = 0;
var pixPerScore = 0;
var floor = 0;
var widthResults = [];
var overlayCanvas = document.getElementById("findWidthOverlay");

function applyWidth(event) {
	var rect = overlayCanvas.getBoundingClientRect();
	var x = event.clientX - rect.left;
	var y = event.clientY - rect.top;

	var min_x = parseInt((x - 4) / pixPerResult);
	var max_x = parseInt((x + 4) / pixPerResult);
	
	var bestScore = 0;
	var bestResult = 0;
	
	for (let i = min_x; i < max_x; i++) {
		if (widthResults[i][1] > bestScore) {
			bestScore = widthResults[i][1];
			bestResult = i;
		}
	}
	
	widthInput.value = bestResult;
	updateBitRaster();
	
}

function getMousePos(event) {
	var rect = overlayCanvas.getBoundingClientRect();
	var x = event.clientX - rect.left;
	var y = event.clientY - rect.top;

	var min_x = parseInt((x - 4) / pixPerResult);
	var max_x = parseInt((x + 4) / pixPerResult);
	
	var bestScore = 0;
	var bestResult = 0;
	
	for (let i = min_x; i < max_x; i++) {
		if (widthResults[i][1] > bestScore) {
			bestScore = widthResults[i][1];
			bestResult = i;
		}
	}
		
	x = bestResult * pixPerResult;
	y = overlayCanvas.height - (bestScore * pixPerScore) + floor;
	
	var ctx = overlayCanvas.getContext("2d");
	ctx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
	ctx.strokeStyle = "#ccccff";
	ctx.strokeRect(x-8, y-8, 16, 16);
}

function getBitLocation(event) {
	var rect = output.getBoundingClientRect();
	var x = parseInt(event.clientX - rect.x);
	var y = parseInt(event.clientY - rect.y);

	var width = parseInt(widthInput.value);
	var scale = parseInt(scaleInput.value);
	
	var bit = startBit + parseInt(x/scale) + parseInt(y/scale)*width;
	var row = parseInt(bit / width);
	var column = bit % width;
	
	document.getElementById('cursorColumn').value = column;
	document.getElementById('cursorRow').value = row;
	document.getElementById('cursorBit').value = bit;

}


function singleColumnBias(column, width, checkBits) {
	var bias = 0;
	var count = 0;
	var total = 0;
	var offset = parseInt(offsetInput.value);
	checkBits = parseInt(checkBits);
	
	if (checkBits > (bits.length - offset)) {checkBits = bits.length - offset;}

	for (var pos=column; pos<checkBits;){
		total += bits[pos];
		pos += width;
		count += 1;
	}
	
	bias = parseFloat(total) / parseFloat(count);
	return bias;

}


function runColumnBias() {
	var width = parseInt(widthInput.value);
	var checkBits = parseInt(document.getElementById('columnBiasInput').value);
	
	var graph = document.getElementById("columnBiasGraph");

	var pixPerResult = graph.width / width;
	var result = 0;
	var results = [];
	var biasString = []
	
	for (var i = 0; i < width; i++) {
		result = singleColumnBias(i, width, checkBits);
		results.push([i, result]);
		biasString.push(parseInt(Math.round(result)));
	}
	
	document.getElementById('columnBiasOutput').value = biasString.join('');
	
	var ctx = graph.getContext("2d");
	ctx.clearRect(0, 0, graph.width, graph.height);
	ctx.strokeStyle = lineColor;
	ctx.beginPath();feedThruScramble
	for (var i = 0; i < results.length; i++) {
		ctx.lineTo(i*pixPerResult, graph.height-(results[i][1]*graph.height));
	}
	ctx.stroke();
}


function runFindWidth() {
	var minWidth = parseInt(document.getElementById('minWidthInput').value);
	var maxWidth = parseInt(document.getElementById('maxWidthInput').value);
	var checkBits = parseInt(document.getElementById('testBitsInput').value);
	
	var graph = document.getElementById("findWidthGraph");

	pixPerResult = graph.width / (maxWidth - minWidth);
	var maxResult = 0;
	var minResult = 1;
	var result = 0;
	widthResults = [];
	
	for (var i = minWidth; i < maxWidth; i++) {
		result = columnBias(i, checkBits);
		widthResults.push([i, result]);
		if (result > maxResult) {maxResult = result;}
		if (result < minResult) {minResult = result;}
	}
	
	var range = maxResult - minResult;
	pixPerScore = (graph.height - 1) / range;
	floor = minResult * pixPerScore;
	
	var ctx = graph.getContext("2d");
	ctx.clearRect(0, 0, graph.width, graph.height);
	ctx.strokeStyle = lineColor
	ctx.beginPath();
	for (var i = 0; i < widthResults.length; i++) {
		ctx.lineTo(i*pixPerResult, graph.height-(widthResults[i][1]*pixPerScore)+floor);
	}
	ctx.stroke();
}

// function to open a toolbox

var openBox = "none";

function closeToolbox(item) {
	if (item == "findWidth") {
		document.getElementById('findWidthGraph').style.visibility = 'hidden';
		document.getElementById('findWidthOverlay').style.visibility = 'hidden';
	}
	
	if (item == 'columnBias') {
		document.getElementById('columnBiasGraph').style.visibility = 'hidden';
	}
	
	document.getElementById(item+"Button").style.backgroundColor = "";
	document.getElementById(item+"Button").style.color = "";
	document.getElementById(item).className = "closedToolbox";
	//document.getElementById("bitRaster").className = "withClosedToolbox";
	openBox = "none";
	setTimeout(updateBitRaster, 1);
}

function openToolbox(item) {
	if (openBox == item) {
		closeToolbox(openBox);
	} else {
		if (openBox != "none") {closeToolbox(openBox);}
		openBox = item;
		document.getElementById(item+"Button").style.backgroundColor = "var(--buttonbgSelected)";
		document.getElementById(item+"Button").style.color = "var(--buttonfgSelected)";
		document.getElementById(item).className = "openToolbox";
		//document.getElementById("bitRaster").className = "withOpenToolbox";
		if (item == "findWidth") {
			setTimeout(showFindWidthGraph, 1000);
			setTimeout(findWidth, 1001);
		}
		if (item == "columnBias") {
			setTimeout(showColumnBiasGraph, 1000);
			setTimeout(runColumnBias, 1001);
		}
	}
	setTimeout(updateBitRaster, 1);
}

function showFindWidthGraph() {
	document.getElementById('findWidthGraph').style.visibility = '';
	document.getElementById('findWidthOverlay').style.visibility = '';
	document.getElementById('findWidthGraph').width = document.getElementById('findWidthGraph').parentElement.clientWidth;
	document.getElementById('findWidthOverlay').width = document.getElementById('findWidthGraph').parentElement.clientWidth;
}

function showColumnBiasGraph() {
	document.getElementById('columnBiasGraph').style.visibility = '';
	document.getElementById('columnBiasGraph').width = document.getElementById('columnBiasGraph').parentElement.clientWidth;
}

// function to update the bit raster

startBit = 0;
function updateBitRaster() {

	var width = parseInt(widthInput.value)
	var scale = parseInt(scaleInput.value)
	var maxWidth = output.parentElement.clientWidth;
	var maxHeight = output.parentElement.clientHeight;
	if (width * scale < maxWidth) {maxHeight+=15;}
	if ( ((bits.length * scale) / width) < maxHeight ) {maxWidth+=5;}
	
	
	var startX = parseInt(output.parentElement.scrollLeft);
	var startY = parseInt(output.parentElement.scrollTop);
	
	var endX = startX + maxWidth;
	var endY = startY + maxHeight;
	
	if (maxWidth > width*scale) { endX = startX + (width*scale) };

		spacer.style.width = width * scale;
		spacer.style.height = (parseInt(bits.length / width) * scale);
		output.width = maxWidth;
		output.height = maxHeight;
		output.style.top = output.parentElement.getBoundingClientRect()['y'];
		output.style.left = output.parentElement.getBoundingClientRect()['x'];
		var ctx = output.getContext("2d");
		ctx.clearRect(0, 0, output.width, output.height);
		ctx.fillStyle = '#fff';
		ctx.fillRect(0,0,output.width, output.height);
		ctx.fillStyle = '#000';
		
		startBit = parseInt( parseInt(offsetInput.value) + (startX) + ((startY)*width) );
		var endBit = parseInt( parseInt(offsetInput.value) + (endX) + ((endY)*width) );
		var x = 0;
		var y = 0;
		var maxX = 0;
		
		bits.slice(startBit,endBit).forEach( function (bit) {
			if (bit == 1) { ctx.rect(x, y, scale, scale); }
			x += scale;
			if (x == (width*scale)) {y+=scale; x=0;}
			if (x > maxX) {maxX = x;}
		})
		ctx.fill();
		
		if (scale > 9) {
			ctx.strokeStyle = '#E00';
			ctx.lineWidth = 0.5;
			lX = 0;
			lY = 0;
			while (lX < maxWidth) {
				lX += scale;
				ctx.moveTo(lX, 0);
				ctx.lineTo(lX, maxHeight);
			}
			while (lY < maxHeight) {
				lY += scale;
				ctx.moveTo(0, lY);
				ctx.lineTo(maxWidth, lY);
			}
			ctx.stroke();
		}

		
		ctx.fillStyle = bitRasterBg;
		ctx.fillRect(maxX, 0, output.width, output.height);
		ctx.fillRect(0, y+scale, output.width, output.height);
		ctx.fillRect(x+scale, y, output.width, output.height); 
	
		updateOtherDisplays(startBit);
}


function hex2bin(hexByte) {
	return ('0000000' + parseInt(hexByte, 16).toString(2)).substr(-8).split('');
}

function loadTextInput(base) {
	data = document.getElementById('textInputArea').value;
	data = data.split('\n').join('');
	data = data.split(' ').join('');
	
	bits = [];
	
	if (base === 2) {
		for (var x=0; x<data.length; x++) {
			bits.push( parseInt( data[x] ) );
		}
	}
	
	if (base === 16) {
		for (var x=0; x<data.length; x+=2) {
			bits.push( ...hex2bin(data.substring(x, x+2)) );
		}
	}
	
	bitsNoOp = [...bits]
	updateBitRaster();
	updateOtherDisplays();
}

// check page load status

if (window.FileList && window.File && window.FileReader) {
	//console.log('doing the things');
	updateBitRaster();

	// file upload

	fileSelector.addEventListener('change', event => {
		var binaryString = '';

		const file = event.target.files[0];
		const reader = new FileReader();
		reader.addEventListener('load', event => {
		
			binaryString = event.target.result;
			var tileReader = new ByteReader( binaryString ), bitArray = [];

			while( !tileReader.EOF() ) {
				bitArray.push( tileReader.readUBits());
			}
		
			bitString = bitArray.join('').split('');
			bits = [];
			
			for (let i = 0; i < bitString.length; i++) { bits.push( parseInt( bitString[i]) ); }
			
			bitsNoOp = [...bits]
			updateBitRaster();
			updateOtherDisplays();
			
		});
		
		reader.readAsBinaryString(file);
	});

	// change width
	document.getElementById('widthInput').addEventListener('change', event => {
		updateBitRaster();
	});

	// change scale
	document.getElementById('scaleInput').addEventListener('change', event => {
		updateBitRaster();
	});

	// change offset
	document.getElementById('offsetInput').addEventListener('change', event => {
		updateBitRaster();
	});

	document.getElementById('binaryViewType').addEventListener('change', event => {
		updateBinaryView();
	});
	
	document.getElementById('binaryViewSpacing').addEventListener('change', event => {
		updateBinaryView();
	});
	
}

function updateOtherDisplays(startBit) {
	if (document.getElementById('hexView').className == 'openToolbox') { updateHexView(); }
	if (document.getElementById('asciiView').className == 'openToolbox') { updateAsciiView(); }
	if (document.getElementById('binaryView').className == 'openToolbox') { updateBinaryView(); }
	if (document.getElementById('columnBias').className == 'openToolbox') { runColumnBias(); }
}

document.onload = updateBitRaster();

function number2LSFBArray(number, length) {
	result = []
	number = ('0'.repeat(length*2) + number.toString(16)).substr(length*-2);
	for (var i=0; i<number.length; i+=2) {
		result.push( parseInt(number.substr(i,2), 16) );
	}
	return result.reverse();
}

function buildWavFile(bytes) {
	var sampleRate = parseInt(document.getElementById("sampleRateInput").value);
	var bitsPerSample = 8;
	var channels = 1;
	var magicNumber1 = (sampleRate * bitsPerSample * channels) / 8;
	var magicNumber2 = (bitsPerSample * channels)

	var wav = [];
	wav.push(...[82, 73, 70, 70] ); //RIFF
	wav.push(...number2LSFBArray(bytes.length + 36, 4) ); //size LSBF
	wav.push(...[87, 65, 86, 69] ); //WAVE
	wav.push(...[102, 109, 116, 32] ); //fmt 
	wav.push(...[16, 0, 0, 0] ); //length of format data
	wav.push(...[1, 0] ); //format
	wav.push(...[channels, 0] ); //channels
	wav.push(...number2LSFBArray(sampleRate, 4) ); //sample rate
	wav.push(...number2LSFBArray(magicNumber1, 4) ); //magic number
	wav.push(...number2LSFBArray(magicNumber2, 2) ); //magic number
	wav.push(...number2LSFBArray(bitsPerSample, 2) ); //magic number
	wav.push(...[100, 97, 116, 97] ); //data
	wav.push(...number2LSFBArray(bytes.length, 4) ); //size LSBF
	//wav.push(...bytes);
	
	return new Uint8Array( wav );
}

function playAudio() {
	var i = 0
	var bytes = [];
	while (i < bits.length) {
		bytes.push( parseInt(bits.slice(i, i+8).join(''), 2) );
		i += 8;
	}
	
	var wav = buildWavFile(bytes)
	bytes = new Uint8Array(bytes)

	// Create blob from Uint8Array & Object URL.
	var blob = new Blob([wav, bytes], { type: 'audio/wav' });
	var url = URL.createObjectURL(blob);

	// Get DOM elements.
	var audio = document.getElementById('audio');
	var source = document.getElementById('source');

	// Insert blob object URL into audio element & play.
	source.src = url;
	audio.load();
	audio.play();
}

</script>

</body></html>
