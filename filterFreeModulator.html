<html>
<title>Filter Free Modulator</title>
<head><style>

body {
	background: black;
	color: white;
	font-family: monospace;
}

a {
	color: white;
}

input, button, select{
	width: 12em;
}

</style>

</head>

<h1>Filter Free Modulator</h1>
<p>
	This tool attempts to produce decent quality modulated waveforms without the need for filters.
	This is achieved by gradually accelerating the state of carrier toward the symbol value,
	rather than instantaneously modulating the carrier to the symbol value.
	Probably not surprising that the resulting waveform looks alot like a filtered waveform -
	So there's no real gain here in terms of the waveform, however in does remove the need for
	filters, and therefore runs much quicker in JavaScript (especially for lower modulation rates,
	which usually require very sharp filters).
</p>

<p>&nbsp;</p>

<table>

	<tr>
		<td>Message:</td>
		<td><input id='messageInput' value='hello world!'></input></td>
		<td>// If left blank, data will be random 1270 bits (0,1,7)</td>
	</tr>

	<tr>
		<td>Carrier Freq:</td>
		<td><input type='number 'id='lowFreqInput' value=400></input></td>
		<td></td>
	</tr>


	<tr>
		<td>Freq / Amplitude Deviation:</td>
		<td><input id='highFreqInput' value=100></input></td>
		<td>// For FSK this is the shift, in ASK this is the amount (100 = 100%, 50 = 50%)</td>
	</tr>

	<tr>
		<td>Baud Rate:</td>
		<td><input id='baudRateInput' value=50></input></td>
		<td>// Rate of modulation</td>
	</tr>

	<tr>
		<td>Sample Rate:</td>
		<td><input id='sampleRateInput' value=8000></input></td>
		<td></td>
	</tr>
	
	<tr>
		<td>Modulation Type:</td>
		<td>
			<select id='modulationTypeInput'>
			<option value='FSK'>FSK</option>
			<option value='ASK'>ASK</option>
			<option value='BPSK'>PSK (BPSK)</option>
			</select>
		</td>
		<td> </td>
	</tr>

	<tr></tr>
	
	<tr>
		<td></td>
		<td><button onclick="generate();">Generate and Play</button></td>
		<td></td>
	</tr>

</table>

<p>&nbsp;</p>

<p><audio controls="controls" id="audio" loop=""><source id="source" src="" type="audio/wav"></audio></p>


<script>

// helper and wrapper functions
// ----------------------------------------------------------------------------

function randomBinary () {
	// 127 bits of 0,1,7 repeated 10 times (1270 bits)
	return '0000001000001100001010001111001000101100111010100111110100001110001001001101101011011110110001101001011101110011001010101111111'.repeat(10)
}

function $(id) {
	return document.getElementById(id)
}

function makeInt(str) {
	return parseInt(str)
}

function dec2bin(dec) {
	return ('0000000' + dec.toString(2)).substr(-8).split('').map(makeInt)
}

function char2dec(cha) {
	return cha.charCodeAt()
}

function dec2hex(dec) {
	return ('00' + dec.toString(16)).substr(-2)
}

function ascii2bits(ascii) {
	// take some ascii (str) text and return an array of bits (ints)
	let bits = ascii.split('')
	bits = bits.map(char2dec)
	bits = bits.map(dec2bin)
	return bits.flat(1)
}

function sample2byte(sample) {
	// convert the sample to a decimal number between 0 and 254
	// add a random offset to negate quantisation noise
	return 127 + parseInt( (Math.random()-0.5) + (sample * 127) )
}

function number2LSBFArray(number, length) {
	result = []
	number = ('0'.repeat(length*2) + number.toString(16)).substr(length*-2)
	for (var i=0; i<number.length; i+=2) {
		result.push( parseInt(number.substr(i,2), 16) )
	}
	return result.reverse();
}

function buildWavHeader(bytes, sampleRate) {
	var bitsPerSample = 8
	var channels = 1
	var magicNumber1 = (sampleRate * bitsPerSample * channels) / 8
	var magicNumber2 = (bitsPerSample * channels)

	var wav = [];
	wav.push(...[82, 73, 70, 70] ) //RIFF
	wav.push(...number2LSBFArray(bytes.length + 36, 4) ) //size LSBF
	wav.push(...[87, 65, 86, 69] ) //WAVE
	wav.push(...[102, 109, 116, 32] ) //fmt 
	wav.push(...[16, 0, 0, 0] ) //length of format data
	wav.push(...[1, 0] ); //format
	wav.push(...[channels, 0] ) //channels
	wav.push(...number2LSBFArray(sampleRate, 4) ) //sample rate
	wav.push(...number2LSBFArray(magicNumber1, 4) ) //magic number
	wav.push(...number2LSBFArray(magicNumber2, 2) ) //magic number
	wav.push(...number2LSBFArray(bitsPerSample, 2) ) //magic number
	wav.push(...[100, 97, 116, 97] ) //data
	wav.push(...number2LSBFArray(bytes.length, 4) ) //size LSBF
	
	return new Uint8Array( wav );
}

function playAudio(bytes, sampleRate) {
	var wav = buildWavHeader(bytes, sampleRate)
	bytes = new Uint8Array(bytes)

	// Create blob from Uint8Array & Object URL.
	var blob = new Blob([wav, bytes], { type: 'audio/wav' })
	var url = URL.createObjectURL(blob)

	// Get DOM elements.
	var audio = document.getElementById('audio')
	var source = document.getElementById('source')

	// Insert blob object URL into audio element & play.
	source.src = url
	audio.load()
	audio.play()
}

function generate() {
	let text = $("messageInput").value
	let lowFrequency = parseFloat( $("lowFreqInput").value )   //Hz
	let highFrequency = parseFloat( $("highFreqInput").value ) // Hz
	let symbolRate = parseFloat( $("baudRateInput").value )    // Symbols per second (Hz)
	let sampleRate = parseFloat( $("sampleRateInput").value )  // Samples per second (Hz).
	let modulation = eval($("modulationTypeInput").value) // ASK or FSK
	
	let bits = ascii2bits(text)
	// if there's no text - just send random bits
	if (text == '') {bits = randomBinary().split('').map(makeInt)}
	let samples = modulation(bits, lowFrequency, highFrequency, symbolRate, sampleRate)
	
	samples = samples.map(sample2byte)
	playAudio(samples, sampleRate)
}

// ----------------------------------------------------------------------------

function buildSymbol(halfSymbolLength, rotationalVelocity) {
    // produces the frequency map for a single symbol
	// halfSymbolLength is the half duration of a symbol in samples (int)
	// rotationalVelocity is the frequency in radians per sample (float)
	return new Array(halfSymbolLength).fill(rotationalVelocity)
}

function buildTransition (halfSymbolLength, startVelocity, stopVelocity) {
	// produces the frequency map for a transition (start to stop)
	// halfSymbolLength is the half duration of a symbol in samples (int)
	// startVelocity is the start frequency in radians per sample (float)
	// stopVelocity is the stop frequency in radians per sample (float)
	let tArray = new Array(halfSymbolLength).fill(startVelocity)
	let delta = stopVelocity - startVelocity
	
	// produce a cosine half-wave starting at the startVelocity, ramping up
	// to the stop frequency. Minimum acceleration is at the first and last
	// transitions, with maximum acceleration around the middle transitions
	// the last point in the transition array should be equal to stopVelocity
	for (let x = 0; x < halfSymbolLength; x++) {
		tArray[x] += Math.cos( (Math.PI * x) / (halfSymbolLength-1) ) * (delta / -2) + delta / 2
	}

	return tArray
}

function frequency2rotationalVelocity(frequency, sampleRate) {
	if (frequency <= 1) { return frequency }
	// 10 Hz at 50 samples per second = 50/10 = 5 (samples per cycle)
	let period = sampleRate / frequency
	// one cycle is 2PI radians
	// velocity is radians per sample
	// 2PI radians / 5 = rotational velocity (radians per sample)
	return (2*Math.PI) / period
}

function buildAmplitudeMap(bits, lowAmplitude, highAmplitude, symbolRate, sampleRate) {
	// very similar to the build frequencyMap function, 
	// except intead of frequency modulation, we're trying to do amplitude modulation
	// so we're just going to make use of the buildFrequencyMap function and get it 
	// to output values between the low and high amplitudes (high is probably always 1)
	
	// the frequency2rotationalVelocity function has been made to just return the input
	// value, if the input value is less than or equal to 1, so it won't modify the
	// amplitude values passed to it
	
	return buildFrequencyMap(bits, lowAmplitude, highAmplitude, symbolRate, sampleRate)

}

function buildFrequencyMap(bits, lowFrequency, highFrequency, symbolRate, sampleRate) {
	let symbolLength = parseInt( (1/symbolRate) * sampleRate )
	let lowVelocity = frequency2rotationalVelocity(lowFrequency, sampleRate)
	let highVelocity = frequency2rotationalVelocity(highFrequency, sampleRate)
	
	let highSwatch = buildSymbol(symbolLength, highVelocity)
	let lowSwatch = buildSymbol(symbolLength, lowVelocity)
	let tLowHighSwatch = buildTransition(symbolLength, lowVelocity, highVelocity)
	let tHighLowSwatch = buildTransition(symbolLength, highVelocity, lowVelocity)
	
	// duplicate last bit so that it gets a full symbol duration
	// as the symbol usually includes a transition
	bits.push(bits[-1])
	
	let frequencyMap = new Array()
	let state = bits[0]
	let lastSwatch = lowSwatch
	
	
	for (let i=1; i<bits.length; i++) {
		// if there was no change, just keep tx-ing
		// the current state, with no change
		if (state == bits[i]) {
			if (state == 0) {
				frequencyMap.push( lowSwatch )
			} else {
				frequencyMap.push( highSwatch )
			}
		// if it changes from one to zero
		// tx the high-to-low transition
		} else if ( state > bits[i] ) {
			frequencyMap.push( tHighLowSwatch )
		// if it changes from zer to one
		// tx the low-to-high transition
		} else {
			frequencyMap.push( tLowHighSwatch )
		}
		
		state = bits[i]
	}
	
	return frequencyMap.flat(1)
}

function FSK(bits, lowFrequency, frequencyDeviation, symbolRate, sampleRate) {
	
	// build the frequency map
	// the frequency map is actually an array of values which are the
	// rotational velocities: high angular velocity = high frequency
	let highFrequency = lowFrequency + frequencyDeviation
	let frequencyMap = buildFrequencyMap(bits, lowFrequency, highFrequency, symbolRate, sampleRate)
	
	// set the angle to zero and init the samples array
	let angle = 0.0
	let samples = new Array()
	
	frequencyMap.forEach( function(f) {
		// change the angle by the rotational velocity
		angle += f
		// caculate the amplitude and push it to the samples
		samples.push( Math.cos(angle) )
	})
	
	return samples
}

function ASK(bits, carrierFrequency, amplitudeDeviation, symbolRate, sampleRate) {
	if (amplitudeDeviation > 200) {
		alert('Are you sure you want an amplitude deviation that high?')
	}
	
	// build the amplitude map
	// the amplitude map is an array of amplitude values
	// for Amplitude Modulation (AM) on the carrier
	let lowAmplitude = 1 - ( 1 * (amplitudeDeviation/100) )
	let highAmplitude = 1
	let amplitudeMap = buildAmplitudeMap(bits, lowAmplitude, highAmplitude, symbolRate, sampleRate)
	
	// set the angle to zero and init the samples array
	let angle = 0.0
	let samples = new Array()
	let f = frequency2rotationalVelocity(carrierFrequency, sampleRate)
	
	amplitudeMap.forEach( function(amplitude) {
		// change the angle by the rotational velocity
		angle += f
		// caculate the amplitude and push it to the samples
		samples.push( amplitude * Math.cos(angle) )
	})
	
	return samples
}

function BPSK(bits, carrierFrequency, nothing, symbolRate, sampleRate) {
	// BPSK can be accomplished just through ASK with a 200% amplitude deviation
	// as 100% - 200% = -100% or -1]
	// -1 amplitude is the same as being 180 degrees out of phase
	return ASK(bits, carrierFrequency, 200, symbolRate, sampleRate)
}

</script>
</html>
