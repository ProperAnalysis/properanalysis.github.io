
<html>
<title>bitView</title>
<style>

:root {

    --backgroundLight: #ffffff;
    --midgroundLight: #d5d5d5;
    --borderColorLight: #8d8d8d;
    --buttonbgLight: #e5e5e5;
    --entrybgLight: #efefef;
    --buttonbgHoverLight: #fdffd0;
    --buttonbgSelectedLight: #fffac6;
    --textColorLight: #000;
    --tableHeadColorLight: #001279;
    --tableHighlightColorLight: #aa0000;
    --tableHighlightColorLight2: #008c00;
    --cellColorLight: #e6e6e6;
    --cellBorderLight: #9e9e9e;
    --cellBorderStrongLight: #666;
    --shadowColorLight: #aaa;
    --tableTopLeftLight: #aaa;
    
    --backgroundDark: #303030;
    --midgroundDark: #111111;
    --borderColorDark: #4d4d4d;
    --entrybgDark: #151515;
    --buttonbgDark: #333333;
    --buttonbgHoverDark: #a28f75;
    --buttonbgSelectedDark: #818181;
    --textColorDark: #fff;
    --tableHeadColorDark: #ffa400;
    --tableHighlightColorDark: #ff0000;
    --tableHighlightColorDark2: #00ff00;
    --cellColorDark: #050505;
    --cellBorderDark: #606060;
    --cellBorderStrongDark: #777;
    --shadowColorDark: #000;
    --tableTopLeftDark: #484848;
    
    --background: var(--backgroundDark);
    --midground: var(--midgroundDark);
    --borderColor: var(--borderColorDark);
    --buttonbg: var(--buttonbgDark);
    --entrybg: var(--entrybgDark);
    --buttonbgHover: var(--buttonbgHoverDark);
    --buttonbgSelected: var(--buttonbgSelectedDark);
    --textColor: var(--textColorDark);
    --tableHeadColor: var(--tableHeadColorDark);
    --tableHighlightColor: var(--tableHighlightColorDark);
    --tableHighlightColor2: var(--tableHighlightColorDark2);
    --cellColor: var(--cellColorDark);
    --cellBorder: var(--cellBorderDark);
    --cellBorderStrong: var(--cellBorderStrongDark);
    --shadowColor: var(--shadowColorDark);
    --tableTopLeft: var(--tableTopLeftDark);
}

*::-webkit-scrollbar {
    -webkit-appearance: none;
}
*::-webkit-scrollbar:vertical {
    width: 11px;
}
*::-webkit-scrollbar:horizontal {
    height: 11px;
}
*::-webkit-scrollbar-thumb {
    border-radius: 8px;
    border: 2px solid var(--midground); /* should match background, can't be transparent */
    background-color: rgba(255, 255, 255, 0.1);
}
*::-webkit-scrollbar-track { 
    background-color: var(--midground); 
    border-radius: 8px; 
} 

::-webkit-scrollbar-corner {
    background-color: var(--midground); 
}

html, body {
	margin: 0; 
	height: 100%; 
	overflow: hidden;
	background-color: var(--background);
}


div {
	transition: max-height 0s;
}

#container {
	width: 100%;
	height: 100%;
	font-family: helvetica;
	font-size: 12pt;
	color: var(--textColor);
	position: absolute;
	display: flex;
	flex-direction: column;
}


#topMenu {
	height: auto;
    width: 100%;
    margin-bottom: 5px;
    display: inline-block;
    flex-shrink: 0;
    flex-grow: 0;
    z-index: 1;
}

.topMenuItem {
	background-color: var(--midground);
	border-radius: 5px;
	height: 20px;
	width: auto;
	float: left;
	margin: 5px;
	margin-right: 0px;
	margin-bottom: 0px;
	padding: 10px;
	border: 1px var(--borderColor) solid;
	box-shadow: 0px 0px 5px 3px var(--shadowColor);
	z-index: 1;
}

.closedToolbox {
	visibility: hidden;
	width: 100%;
	height: 0px;
	max-height: 0px;
}

.openToolbox {
	visibility: unset;
	width 100%;
	height: auto;
	margin-top: 5px;
	padding-top: 5px;
	max-height: 9001;
	z-index: 1;
}

#bitRasterOuter {
	background-color: var(--midground);
	width: calc(100% - 33px);
	padding: 10px;
	margin: 5px;
	margin-top: 0px;
	margin-bottom: 5px;
	border-radius: 5px;
	border: 1px var(--borderColor) solid;
	flex-shrink: 1;
	flex-grow: 1;
	display: flex;
	flex-direction: column;
	max-height: 100%;
	box-shadow: 0px 0px 5px 3px var(--shadowColor);
}

#bitRasterInner {
	overflow: scroll;
    height: 1;
    width: 100%;
    flex-shrink: 1;
    flex-grow: 1
}



#bottomMenuContainer {
	background-color: var(--midground);
	width: calc(100% - 33px);
	height: fit-content;
	padding: 10px;
	margin: 5px;
	margin-bottom: 0px;
	border-radius: 5px;
	overflow: hidden;
	border: 1px var(--borderColor) solid;
	flex-shrink: 0;
	flex-grow: 0;
	box-shadow: 0px 0px 5px 3px var(--shadowColor);
	z-index: 1;
}

#bottomMenu {
	width: 100%;
	z-index: 1;
}


button, input::file-selector-button, input[type="number"], input[type="text"], select{
	background-color: var(--buttonbg);
	border: 0px;
	border-radius: 2px;
	color: var(--textColor);
	margin: 2px;
}

input[type="number"], input[type="text"], select {
	width: 60pt;
}

button:hover, input::file-selector-button:hover{
	background-color: var(--buttonbgHover);
}

.opsConfig {
	margin: 10px;
	overflow-y: scroll;
	width: auto;
	height: calc(100% - 40pt);
	font-size: 10pt;
}

.opsConfigHidden {
	display: none;
}

</style>
</head>

<body>
<canvas width="1920" height="969" id="background" style="position: absolute; z-index: 0;"></canvas>
<div id="container">

<div id="bottomMenuContainer">
<div id="bottomMenu">
<button id="inputMenuButton" onclick="openToolbox(&#39;inputMenu&#39;);" style="">Input Select</button>
<button id="findWidthButton" onclick="openToolbox(&#39;findWidth&#39;);">Find Width</button>
<button id="columnBiasButton" onclick="openToolbox(&#39;columnBias&#39;);">Column Bias</button>
<button id="asciiViewButton" onclick="openToolbox(&#39;asciiView&#39;); updateAsciiView();">ASCII View</button>
<button id="hexViewButton" onclick="openToolbox(&#39;hexView&#39;); updateHexView();" style="">Hex View</button>
<button id="binaryViewButton" onclick="openToolbox(&#39;binaryView&#39;); updateBinaryView();">Binary View</button>
<button id="operationsButton" onclick="openToolbox(&#39;operations&#39;)" style="">Operations</button>
<button id="outputMenuButton" onclick="openToolbox(&#39;outputMenu&#39;);">Output</button>
</div>


<div id="inputMenu" class="closedToolbox">
<input type="file" id="fileSelector">
</div>

<div id="outputMenu" class="closedToolbox">
<div style="display: flex;">
<button id="outputGenerateButton" onclick="generateOutput();">Generate Output</button><div id="outputList" style="font-size: 8pt; margin-left: 10px; margin-top: 5px;"></div>
</div>
</div>

<div id="findWidth" class="closedToolbox">
<canvas id="findWidthGraph" width="1" height="265" style="border:0px; position: absolute; left: 20; z-index: 0; visibility: hidden;" "=""></canvas>
<canvas id="findWidthOverlay" onmousemove="getMousePos(event)" onclick="applyWidth(event)" width="1" height="265" style="visibility: hidden; border:0px; position: absolute; left: 20; z-index: 1;" "=""></canvas>
<div id="spacer" style="width: 100%; height: 265px;"></div>
<div style="padding-top: 5px; padding-right: 10px;">
Min Width: <input type="number" id="minWidthInput" value="0">
Max Width: <input type="number" id="maxWidthInput" value="1000">
Bits to Test: <input type="number" id="testBitsInput" value="100000">
<button id="goFindWidthButton" onclick="findWidth();">Go</button>
</div>
</div>

<div id="columnBias" class="closedToolbox">
<canvas id="columnBiasGraph" width="1" height="155" style="border:0px; position: absolute; left: 20; z-index: 0; visibility: hidden; margin-bottom: 10px;"></canvas>
<div id="spacer" style="width: 100%; height: 165px;"></div>
<textarea disabled="" id="columnBiasOutput" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; font-family: monospace; color: #fff; width: 100%; height: 100px; background-color: var(--midground);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
<div style="padding-top: 5px; padding-right: 10px;">
Bits to Test: <input type="number" id="columnBiasInput" value="100000">
<button id="goColumnBiasButton" onclick="runColumnBias();">Go</button>
</div>
</div>


<div id="asciiView" class="closedToolbox">
<textarea disabled="" id="asciiViewOutput" style="font-family: monospace; color: #fff; width: 100%; height: 265px; background-color: var(--midground);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
</div>

<div id="hexView" class="closedToolbox">
<textarea disabled="" id="hexViewOutput" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; font-family: monospace; color: #fff; width: 100%; height: 265px; background-color: var(--midground);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E 7E
</textarea>
</div>

<div id="binaryView" class="closedToolbox">
<textarea disabled="" id="binaryViewOutput" style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; font-family: monospace; color: #fff; width: 100%; height: 265px; background-color: var(--midground);" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>
</div>

<div id="operations" class="closedToolbox" style="overflow-y: hidden; overflow-x: hidden; display: -webkit-box;">

<div id="operationTypes" style="width: 20%; height: 270px; padding-right: 5px; overflow-y: scroll;">
<p style="text-align: center;">Operations Menu</p>
<button style="width: 100%;" onclick="addOperation(&#39;additiveScramble&#39;, [&#39;0,1,7&#39;, &#39;No&#39;, &#39;1&#39;, &#39;0&#39;, &#39;0&#39;]);">additiveScramble</button>
<button style="width: 100%;" onclick="addOperation(&#39;feedThruScramble&#39;, [&#39;0,1,7&#39;, &#39;No&#39;]);">feedThruScramble</button>
<button style="width: 100%;" onclick="addOperation(&#39;feedThruDescramble&#39;, [&#39;0,1,7&#39;, &#39;No&#39;]);">feedThruDescramble</button>
<button style="width: 100%;" onclick="addOperation(&#39;applyDelta&#39;, [1]);">applyDelta</button>
<button style="width: 100%;" onclick="addOperation(&#39;applyXOR&#39;, [&#39;0&#39;, 0]);">applyXOR</button>
<button style="width: 100%;" onclick="addOperation(&#39;&#39;, []);">frameSync</button>
<button style="width: 100%;" onclick="addOperation(&#39;takeSkip&#39;, [&#39;t256&#39;]);">takeSkip</button>
<button style="width: 100%;" onclick="addOperation(&#39;invertBits&#39;, []);">invertBits</button>
<button style="width: 100%;" onclick="addOperation(&#39;repeatBits&#39;, [0, 1]);">repeatBits</button>
<button style="width: 100%;" onclick="addOperation(&#39;snipBits&#39;, [0, 0]);">snipBits</button>
<button style="width: 100%;" onclick="addOperation(&#39;addBits&#39;, [0, 1, &#39;&#39;]);">addBits</button>
</div>

<div style="width 1px; height 1px; border: 1px solid var(--borderColor);"></div>

<div id="operationsListContainer" style="width: 20%; height: 270px; overflow-y: scroll;">
<p style="text-align: center;">Applied Operations</p>
<div id="operationsList"></div>
</div>

<div style="width 1px; height 1px; border: 1px solid var(--borderColor);"></div>

<div id="operationsConfig" style="#0000aa; width: 60%; height: 270px;">
<p style="text-align: center;">Operation Configuration</p>

<div id="applyDeltaConfig" class="opsConfigHidden">
<p>Apply Delta</p>
<p>Used for removing differential encoding. This function takes a bit, compares it with another bit, then returns the result. For example 110 becomes 01, the "delta" between 1 and 1 being 0 and the "delta" between 1 and 0 being 1.</p>Changing the "offset" changes how many bits between delta comparisons. This allows for the delta to be applied down a column for example. At a width of 256, to apply a delta down each column, use an offset of 256.
<p>Offset: <input type="number" id="applyDelta0" value="0"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="takeSkipConfig" class="opsConfigHidden">
<p>Take Skip</p>
<p>Used to skip or change bits based on a 'command string'. Each command must be separated by a comma (,).
</p><p>Letters for the command string are: Take some bits (t), skip some bits (s), invert some bits (i), insert some zero some bits (z) or reverse some bits (r).
</p><p>The number after each letter indicates the number of bits to perform the action on. For example: t1,s2 will take one bit, then skip two bits.
</p><p>Command: <input type="text" id="takeSkip0" value="-"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="repeatBitsConfig" class="opsConfigHidden">
<p>Repeat Bits</p>
<p>Used to repeat or duplicate a set of bits a number of times. Note that all bits in the file will be repeated.
</p><p>"Chunk Size" refers to the number of bits to repeat or duplicate. Set to 0 to repeat the entire file.
</p><p>"Repeat Count" refers to the number of times to repeat before moving to the next chunk.
</p><p>Chunk Size: <input type="number" id="repeatBits0" value="0"></p>
<p>Repeat Count: <input type="number" id="repeatBits1" value="1"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="snipBitsConfig" class="opsConfigHidden">
<p>Snip Bits: Used to cut down a bit file by dropping bits from the the start and/or end of the file.
</p><p>"Start" refers to the number of bits to drop at the start of the file. 0 will keep all start bits. Negative numbers will start a number of bits from the end of the file.
</p><p>"Keep" refers to the number of bits to keep. 0 will keep all all end bits. Negative numbers will keep a number of bits from the end of a file.
</p><p>Start: <input type="number" id="snipBits0" value="0"> <button onclick="increase(&#39;snipBits0&#39;);">+</button><button onclick="decrease(&#39;snipBits0&#39;);">-</button><input type="number" id="snipBits0Increment" value="0"> <button onclick="useBitRasterScroll(&#39;snipBits0&#39;);">Use Bitraster Scroll</button> </p>
<p>Keep: <input type="number" id="snipBits1" value="0"> <button onclick="increase(&#39;snipBits1&#39;);">+</button><button onclick="decrease(&#39;snipBits1&#39;);">-</button><input type="number" id="snipBits1Increment" value="0"> <button onclick="useBitRasterScroll(&#39;snipBits1&#39;);">Use Bitraster Scroll</button> </p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="addBitsConfig" class="opsConfigHidden">
<p>Add Bits: Used to append bits to a bit file, at a given bit position.
</p><p>Postion 0 is the start of the file, position -1 is the end of the file. Position 1 is 1 bit from the start of the file, etc.
</p><p>Position: <input type="number" id="addBits0" value="0"> <button onclick="increase(&#39;addBits0&#39;);">+</button><button onclick="decrease(&#39;addBits0&#39;);">-</button><input type="number" id="addBits0Increment" value="0"> <button onclick="useBitRasterScroll(&#39;addBits0);">Use Bitraster Scroll</button> </p>
<p>Iterations: <input type="number" id="addBits1" value="0"></p>
<p>Bits: <input type="text" style="width: calc(100% - 3.5em);" id="addBits2" value="0"></p>
<p><button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</p></div>

<div id="feedThruScrambleConfig" class="opsConfigHidden">
<p>Feed Through Scrambler: Scrambles bits using the feed through method.</p>
<p>Described using "taps". For example: 0,1,7 creates a register of length 7, with tap points at the 0th, 1st and 7th bits. As bits move through the register, the tap points are added to create the scrambled output stream.</p>
<p>Use the "feedThruDescramble" to remove a feed through randomiser.</p>
<p>Taps: <input type="text" id="feedThruScramble0" value="0"> (First tap point should always be 0) </p>
<p>Reverse Taps:
<select id="feedThruScramble1" value="No">
<option value="No">No</option>
<option value="Yes">Yes</option>
</select>
</p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>
 
<div id="feedThruDescrambleConfig" class="opsConfigHidden">
<p>Feed Through Descrambler: Descrambles bits using the feed through method.</p>
<p>Described using "taps". For example: 0,1,7 creates a register of length 7, with tap points at the 0th, 1st and 7th bits. As bits move through the register, the tap points are added to create the scrambled output stream.</p>
<p>Taps: <input type="text" id="feedThruDescramble0" value="0"> (First tap point should always be 0) </p>
<p>Reverse Taps:
<select id="feedThruDescramble1" value="No">
<option value="No">No</option>
<option value="Yes">Yes</option>
</select>
</p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="additiveScrambleConfig" class="opsConfigHidden">
<p>Additive Scrambler: Scrambles (or descrambles) bits using the additive method.</p>
<p>Generates a pseudorandom binary stream and XORs the data against this stream.</p>
<o>Note that the reverse of this opperation is just to repeat the operation with the same settings.
<p>Taps: <input type="text" id="additiveScramble0" value="0"> (First tap point should always be 0) </p>
<p>Reverse Taps:
<select id="additiveScramble1" value="No">
<option value="No">No</option>
<option value="Yes">Yes</option>
</select>
</p>
<p>Initial Fill: <input type="text" id="additiveScramble2" value="0"> (1 = all 1s, 0 = all 0s)</p>
<p>Length: <input type="number" id="additiveScramble3" value="0"> (0 = maximal)</p>
<p>Rotation: <input type="number" id="additiveScramble4" value="0"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</o></div>

<div id="applyXORConfig" class="opsConfigHidden">
<p>applyXOR: (eXclusive OR) A Boolean logic operation. Compares two input bits and generates one output bit. If the bits are the same, the result is 0. If the bits are different, the result is 1.</p>
<p>Provide a binary string to "XOR" against and an offset. The string will then be XORed against the bit file and repeated for the entire file.
</p><p>Binary String: <input type="text" id="applyXOR0" value="0"></p>
<p>Offset: <input type="number" id="applyXOR1" value="0"></p>
<button onclick="updateOperation();">Apply</button>
<button onclick="closeConfigureOperation();">Close</button>
</div>

<div id="invertBitsConfig" class="opsConfigHidden">
<p>Inverts all of the bits. Could also be achieved with XOR "1" or takeSkip "i1", however invertBits is much faster.
</p></div>


</div>
</div>
</div>


<div id="topMenu">

<div class="topMenuItem">
Width: <input type="number" id="widthInput" value="512">
</div>

<div class="topMenuItem">
Offset: <input type="number" id="offsetInput" value="0">
</div>

<div class="topMenuItem">
Scale: <input type="number" id="scaleInput" value="2">
</div>

<div class="topMenuItem">
Column: <input type="text" id="cursorColumn" value="0">
</div>

<div class="topMenuItem">
Row: <input type="text" id="cursorRow" value="0">
</div>

<div class="topMenuItem">
Bit: <input type="text" id="cursorBit" value="0">
</div>

</div>

<div id="bitRasterOuter">
<div id="bitRasterInner">
<div id="outputSpacer" style="width: 1024px; height: 15720px;"></div>
<canvas id="output" width="1389" height="600" style="border: 0px; position: absolute; z-index: 0; top: 126.5px; left: 21px;" onmousemove="getBitLocation(event)"></canvas>
</div>
</div>

</div>



<script>

String.prototype.replaceAll = function(str1, str2, ignore) 
{
    return this.replace(new RegExp(str1.replace(/([\/\,\!\\\^\$\{\}\[\]\(\)\.\*\+\?\|\<\>\-\&])/g,"\\$&"),(ignore?"gi":"g")),(typeof(str2)=="string")?str2.replace(/\$/g,"$$$$"):str2);
} 

function ByteReader( bytedata ) {
this._data = bytedata || "";
this._offset = 0;
}

ByteReader.prototype = {

	constructor: ByteReader,

	EOF: function(){
	return this._offset >= this._data.length;
	},

	tellSize: function(){
	return this._data.length;
	},

	seekTo: function( offset ){
	this._offset = offset;
	return this;
	},

	rewind: function() {
	this._offset = 0;
	return this;
	},

	readBytes: function( bytes ) {
	var s = this._data.substr( this._offset, bytes );
	this._offset += bytes;
	return s;
	},

	setByteStream: function( data ) {

		if( typeof data != "string" )
		throw new TypeError( typeof data + " must be string" );

	this._data = data;
	this._offset = 0;
	return this;
	},

	readDouble: function( littleEndian ) {
	var s = this.readBytes( 8 );
	var pow = Math.pow, sign, exponent, fraction;

		if( littleEndian )
		s = s.split("").reverse().join("");

	sign =  ( s.charCodeAt(0) & 0x80 ) >> 7;
	exponent =  ( ( s.charCodeAt(0) & 0x7F ) << 4 ) | ( ( s.charCodeAt(1) & 0xF0 ) >> 4 );
	fraction =  ( ( s.charCodeAt(1) & 0x0F ) * pow(2, 48) ) +
			s.charCodeAt(2) * pow( 2, 40 ) +
			s.charCodeAt(3) * pow( 2, 32 ) +
			( ( s.charCodeAt(4) & 0xFF ) << 24 ) +
			( ( s.charCodeAt(5) & 0xFF ) << 16 ) +
			( ( s.charCodeAt(6) & 0xFF ) << 8  ) +
			s.charCodeAt(7);

	sign = pow( -1, sign );

		if( exponent === 2047 ) {
			if( fraction !== 0)
			return Number.NaN;

			else if( sign < 0 )
			return -Infinity;

			else
			return Infinity;
		}
		else if( exponent > 0 )
		return sign * Math.pow( 2, exponent - 1023 ) * ( fraction / 0x10000000000000 + 1 );


		else if ( fraction !== 0 )
		return sign * Math.pow( 2, -1022 ) * ( fraction / 0x10000000000000 );


		else 
		return 0;

	},

	readSingle: function( littleEndian ) {
	var s = this.readBytes( 4 )
	var sign, exponent, fraction;

		if( littleEndian )
		s = s.split("").reverse().join("");

	sign =  ( s.charCodeAt(0) & 0x80 ) >> 7;
	exponent =  ( ( s.charCodeAt(0) & 0x7F ) << 1 )  | ( ( s.charCodeAt(1) & 0x80 ) >> 7 );
	fraction =  ( ( s.charCodeAt(1) & 0x7F ) << 16 ) |
			( ( s.charCodeAt(2) & 0xFF ) << 8 )  |
			( s.charCodeAt(3) & 0xFF );

	sign = Math.pow( -1, sign );

		if( exponent === 255 ) {

			if( fraction !== 0 )
			return Number.Nan;

			else if( sign < 0 )
			return -Infinity;

			else
			return Infinity;
		}
		else if( exponent > 0 )
		return sign * Math.pow(2, exponent - 127) * ( fraction / 0x800000 + 1 );

		else if ( fraction !== 0 )
		return sign *  Math.pow(2, -126) * ( fraction / 0x800000 );

		else
		return 0;

	},

	readSByte: function() {
	var s = this.readBytes( 1 ).charCodeAt( 0 ) & 0xFF;
	return ( s ^ 0x80 ) - 0x80;
	},

	readUByte: function() {
	return this.readBytes( 1 ).charCodeAt( 0 ) & 0xFF;
	},
	
	readUBits: function() {
	return ('00000000'+ ( this.readBytes( 1 ).charCodeAt( 0 ) & 0xFF).toString(2)).slice(-8);
	},

	readUShort: function( littleEndian ) {
	var s = this.readBytes( 2 );

		if( littleEndian )
		return ( s.charCodeAt( 0 ) & 0xFF ) |
		( ( s.charCodeAt( 1 ) & 0xFF) << 8 );

		else
		return ( s.charCodeAt( 1 ) & 0xFF ) |
		( ( s.charCodeAt( 0 ) & 0xFF) << 8 );
	},

	readULong: function( littleEndian ) {
	var s = this.readBytes( 4 ), r;

		if( littleEndian ) 
		r = ( s.charCodeAt( 0 ) & 0xFF )        |
		( ( s.charCodeAt( 1 ) & 0xFF ) << 8 )   |
		( ( s.charCodeAt( 2 ) & 0xFF ) << 16 )  |
		( ( s.charCodeAt( 3 ) & 0xFF ) << 24 );

		else
		r = ( s.charCodeAt( 3 ) & 0xFF )        |
		( ( s.charCodeAt( 2 ) & 0xFF ) << 8 )   |
		( ( s.charCodeAt( 1 ) & 0xFF ) << 16 )  |
		( ( s.charCodeAt( 0 ) & 0xFF ) << 24 );

		if ( r & 0x80000000 )
		r = ( r & 0x7FFFFFFF ) + 0x80000000;

	return r;
	},

	readSShort: function( littleEndian ){
	var s = this.readBytes( 2 ), r;

		if( littleEndian )
		r = ( s.charCodeAt( 0 ) & 0xFF ) |
		( ( s.charCodeAt( 1 ) & 0xFF) << 8 );

		else
		r = ( s.charCodeAt( 1 ) & 0xFF ) |
		( ( s.charCodeAt( 0 ) & 0xFF) << 8 );

	return ( r ^ 0x8000 ) - 0x8000;
	},

	readSLong: function( littleEndian ){
	var s = this.readBytes( 4 ), r;

		if( littleEndian ) 
		return ( s.charCodeAt( 0 ) & 0xFF ) |
		( ( s.charCodeAt( 1 ) & 0xFF ) << 8 )   |
		( ( s.charCodeAt( 2 ) & 0xFF ) << 16 )  |
		( ( s.charCodeAt( 3 ) & 0xFF ) << 24 );

		else
		return ( s.charCodeAt( 3 ) & 0xFF ) |
		( ( s.charCodeAt( 2 ) & 0xFF ) << 8 )   |
		( ( s.charCodeAt( 1 ) & 0xFF ) << 16 )  |
		( ( s.charCodeAt( 0 ) & 0xFF ) << 24 );

	}


};



const status = document.getElementById('status');
const output = document.getElementById('output');
const spacer = document.getElementById('outputSpacer');
const biasView = document.getElementById('biasView');
const widthInput = document.getElementById('widthInput');
const scaleInput = document.getElementById('scaleInput');
const fileSelector = document.getElementById('fileSelector')
const offsetInput = document.getElementById('offsetInput');
const positionOutput = document.getElementById('position');
const operationsListHTML = document.getElementById('operationsList');
var operationsList = [];

var bits = Array(10000).fill(0);
var bitsNoOp = [...bits];

var mouseX = 0;
var mouseY = 0;
document.onmousemove = function(event) {
        mouseX = event.pageX;
        mouseY = event.pageY;
    };

document.addEventListener("wheel", function(e){
  // prevent the default scrolling event
  var bounds = output.getBoundingClientRect()
  if (mouseY > bounds['top'] && mouseY < bounds['bottom'] && mouseX > bounds['left'] && mouseX < bounds['right']) {
		output.parentElement.scrollBy(e.deltaX, e.deltaY);
	}
});

output.parentElement.onscroll = function (e) {  
	updateBitRaster();
};


function makeInt(item) {
	return parseInt(item);
}

function generateBytes() {
	var bytes = new Uint8Array(bits.length / 8);
	var byte = 0
	for (let i = 0; i < bits.length; i+=8) {
		bytes[byte] = parseInt( bits.slice(i, i+8).join(''), 2);
		byte++;
	}

	return bytes;
}
 
function generateOutput() {
	list = document.getElementById("outputList");

	while (list.hasChildNodes()) {
		list.removeChild(list.firstChild);
	}

	var d = new Date();
	let time = d.getTime();

	let link = document.createElement('a');
	link.innerHTML = time + '_output.bit';
	link.download = time + '_output.bit';
	link.style = 'color: white;'
	let bytes = generateBytes();
	let  blob = new Blob([bytes], { type: 'application/octet-stream' });
	link.href = URL.createObjectURL(blob);
	list.appendChild(link);
}
 
function arraysEqual(a, b) {
	if (a === b) return true;
	if (a == null || b == null) return false;
	if (a.length !== b.length) return false;

	for (var i = 0; i < a.length; ++i) {
		if (a[i] !== b[i]) return false;
		}
	return true;
}

function applyXOR(binaryString, offset) {
	binaryString = binaryString.split('').map(makeInt);
	offset = parseInt(offset);
	
	if (offset < 0) {offset = binaryString.length - (offset % binaryString.length);}	
	newBits = new Array(bits.length);
	//console.log(binaryString, offset);
	
	for (let i = 0; i < bits.length; i++) {
		newBits[i] = (bits[i] + binaryString[(i+offset) % binaryString.length]) % 2;
	}
	
	bits = newBits;
	delete newBits;
}

function additiveScramble(taps, reversed, fill, length, rotation) {
	//console.log(taps, reversed, fill, length, rotation);
	taps = taps.split(',').map(makeInt);
	var tapsRev = [];
	var lastTap = taps.slice(-1)[0];

	tapsRev.push(taps[0]);
	for (let i = 1; i < taps.length - 1; i++) {
		tapsRev.push(lastTap - taps[i]);
	}
	tapsRev.push(lastTap);

	if (reversed == 'No') {taps = tapsRev;}
	
	var register = fill.repeat(lastTap).split('').slice(0, lastTap).map(makeInt);
	var scramble = [];
	
	length = parseInt(length);
	var bit = 0;
	var initial = register.join('');
	
	if (length == 0) {
		
		do {
			bit = 0;

			for (let x = 1; x < taps.length; x++) {
				bit = bit + register[taps[x]-1];
			}

			bit = bit % 2;
			register.unshift(bit);
			register.pop();
			scramble.push(bit);
		}
		while (initial != register.join(''));
	
	} else {
	
		do {
			bit = 0;

			for (let x = 1; x < taps.length; x++) {
				bit = bit + register[taps[x]-1];
			}

			bit = bit % 2;
			register.unshift(bit);
			register.pop();
			scramble.push(bit);
		}
		while (scramble.length < length);
	
	}
	
	//console.log(output);
	
	rotation = parseInt(rotation);
	if (rotation < 0) {rotation = output.length - (rotation % output.length);}	
	//newBits = new Array(bits.length);
	
	for (let i = 0; i < bits.length; i++) {
		bits[i] = (bits[i] + scramble[(i+rotation) % scramble.length]) % 2;
	}
	
}

function feedThruScramble(taps, reversed) {
	taps = taps.split(',').map(makeInt);
	var tapsRev = [];
	var lastTap = taps.slice(-1)[0];

	tapsRev.push(taps[0]);
	for (let i = 1; i < taps.length - 1; i++) {
		tapsRev.push(lastTap - taps[i]);
	}
	tapsRev.push(lastTap);

	if (reversed == 'No') {taps = tapsRev;}

	register = new Array(lastTap).fill(0);
	newBits = new Array(bits.lenght);
	
	for (let a = 0; a < taps.length; a++) {
		taps[a] = Math.abs(taps[a] - lastTap);
	}
	
	//console.log(taps);
   
	var bit = 0;
	var offset = 0;
	for (let i = 0; i < bits.length; i++) {
		bit = bits[i];

		for (let x = 1; x < taps.length; x++) {
			bit = bit + register[taps[x] + offset];
		}

		bit = bit % 2;
		register.push(bit);
		newBits[i] = bit;
		offset++;
	}

	bits = newBits;
	delete newBits;
}
 
function feedThruDescramble(taps, reversed) {
	taps = taps.split(',').map(makeInt);
	var tapsRev = [];
	var lastTap = taps.slice(-1)[0];

	tapsRev.push(taps[0]);
	for (let i = 1; i < taps.length - 1; i++) {
		tapsRev.push(lastTap - taps[i]);
	}
	tapsRev.push(lastTap);

	if (reversed == 'No') {taps = tapsRev;}

	register = new Array(lastTap).fill(0);
	newBits = new Array(bits.lenght);
	
	for (let a = 0; a < taps.length; a++) {
		taps[a] = Math.abs(taps[a] - lastTap);
	}
	
	var bit = 0;
	var offset = 0;
	for (let i = 0; i < bits.length; i++) {
		bit = bits[i];
		register.push(bit);
		offset++;

		for (let x = 1; x < taps.length; x++) {
			bit = bit + register[taps[x] + offset -1];
		}

		bit = bit % 2;
		newBits[i] = bit;
		
	}

	bits = newBits;
	delete newBits;
}


function updateAsciiView() {
	var width = parseInt(widthInput.value);
	var ascii = [];
	var line = [];
	var x = 0;
	
	for (let i = parseInt(offsetInput.value); i < bits.length; i+=8) {
		line.push( String.fromCharCode( parseInt( bits.slice(i, i+8).join(''), 2) ) );
		x+=1;
		if (x == width) {
			ascii.push(line.join(''));
			x = 0;
			line = [];
		}
		
	}
	ascii.push(line.join(''));
	document.getElementById('asciiViewOutput').value = ascii.join('');

}


function updateHexView() {
	var width = parseInt(widthInput.value);
	var hex = [];
	var line = [];
	var x = 0;
	var leftOver = 0;
	
	for (let i = parseInt(offsetInput.value); i < bits.length;) {
		line.push( ('00' + parseInt(bits.slice(i, i+8).join(''), 2).toString(16).toUpperCase()).slice(-2) );
		i+=8;
		x+=8;
		if (x == width) {
			hex.push(line.join(' '));
			x = 0;
			line = [];
		}
		
		if (x+8 >= width) {
			leftOver = width - x;
			line.push( ('00' + parseInt(bits.slice(i, i+leftOver).join(''), 2).toString(16).toUpperCase()).slice(-2) );
			hex.push(line.join(' '));
			i += leftOver;
			x = 0;
			line = [];
		}
		
	}
	hex.push(line.join(' '));
	document.getElementById('hexViewOutput').innerHTML = hex.join('\n');

}

function updateBinaryView() {
	var width = parseInt(widthInput.value);
	var binary = [];
	
	for (var i = parseInt(offsetInput.value); i < bits.length-width;) {
		binary.push(bits.slice(i, i+width).join(''));
		i += width;
	}
	
	binary.push(bits.slice(i, bits.length).join(''));
			
	document.getElementById('binaryViewOutput').innerHTML = binary.join('\n');

}

function addOperation(operation, args) {
	operationsList.push([operation, args]);
	operationsListHTML.innerHTML = "";
	operationsList.forEach(addToOpsListDisplay);
	runOperations();
}

function closeConfigureOperation() {
	document.getElementsByClassName('opsConfig')[0].className = 'opsConfigHidden';
}

var openOpsConfig = null;

function configureOperation(index) {
	if (document.getElementsByClassName('opsConfig').length > 0) {
		closeConfigureOperation();
	}
	
	for (let a=0; a < operationsList.length; a++) {
		document.getElementById('configureButton' + a).style.backgroundColor = '';
	}
	
	document.getElementById('configureButton' + index).style.backgroundColor = 'var(--buttonbgSelected)';
	
	var type = operationsList[index][0];
	var args = operationsList[index][1];
	var configObject = document.getElementById(type + 'Config');
	configObject.className = 'opsConfig';
	
	for (let i=0; i < args.length; i++) {
		document.getElementById(type + i).value = args[i];
	}
	
	openOpsConfig = index;
}

function updateOperation() {
	var type = operationsList[openOpsConfig][0]
	var args = operationsList[openOpsConfig][1]
	
	for (let i = 0; i < args.length; i++) {
		args[i] = document.getElementById(type+i).value;
	}
	operationsList[openOpsConfig] = [type, args];
	runOperations();
	
}

function addToOpsListDisplay(item, index) {
	operationsListHTML.innerHTML +=
	"<button id='configureButton" + index  + "' style='width: calc(85% - 4px);'" +
	"onclick='configureOperation(" + index + ")'" +
	">" + item[0] + "</button>" +
	"<button style='width: calc(15% - 4px);'" + 
	"onclick='removeOperation(" + index + ")'" +
	">X</button>";
}

function removeOperation(index) {
	if (document.getElementsByClassName('opsConfig').length > 0) {
		closeConfigureOperation();
	}
	operationsList.splice(index, 1);
	operationsListHTML.innerHTML = "";
	operationsList.forEach(addToOpsListDisplay);
	runOperations();
}

function runOperations() {
	bits = [...bitsNoOp]
	operationsList.forEach(runOperation);
	updateBitRaster();
}

function runOperation(operation) {
	var operationName = operation[0];
	var operationArguments = operation[1];
	var command = operationName + '("' + operationArguments.join('","') + '");'
	console.log(command);
	eval(command);
}

function applyDelta(offset) {
	//console.log(offset);
	newBits = new Array(bits.length);
	for (let i = 0; i < bits.length-1; i++) { 
		newBits[i] = (bits[i] + bits[i+parseInt(offset)]) % 2;
	}
	bits = newBits;
	delete newBits;
}

function invert(bit, index) {
	return (bit + 1) % 2;
}

function invertBits() {
	bits = bits.map(invert);
}


function repeatBits(chunkSize, timesToRepeat) {
	chunkSize = parseInt(chunkSize);
	timesToRepeat = parseInt(timesToRepeat);
	
	if (chunkSize == 0) {chunkSize = bits.length;}

	if (chunkSize == bits.length) {
		bits = bits.join('').repeat(timesToRepeat+1).split('');
	} else {
	
		newBits = new Array();
		
		for (let i = 0; i < bits.length;) {
			for (let x=0; x < timesToRepeat+1; x++) {
				newBits.push( ...bits.slice(i,i+chunkSize) );
			}
			i += chunkSize;
		}
		bits = newBits;
		delete newBits;
	}
}


function addBits(start, iterations, bitsToAdd) {
	start = parseInt(start);
	bitsToAdd = bitsToAdd.repeat(iterations);
	bitsToAdd = bitsToAdd.split('').map(makeInt);

	if (start > -1) {
		newBits = bits.slice(0, start);
		newBits = newBits.concat(bitsToAdd);
		newBits.push( ...bits.slice(start) );
	} else {
		start = start * -1
		var revBits = bits;
		revBits.reverse();
		bitsToAdd.reverse();
		
		newBits = revBits.slice(0, start-1);
		newBits.push( ...bitsToAdd );
		newBits.push( ...revBits.slice(start-1) );
		newBits.reverse();
	}
	
	bits = newBits;
	delete newBits;
}

function snipBits(start, keep) {
	start = parseInt(start);
	keep = parseInt(keep);
	
	if (keep == 0) {
		bits = bits.slice(start);
	} else if (keep < 0) {
		bits = bits.slice(start, keep);
	} else {
		bits = bits.slice(start, start+keep);
	}
}

function increase(field) {
	document.getElementById(field).value = parseInt(document.getElementById(field).value) + parseInt(document.getElementById(field + 'Increment').value);
	updateOperation();
}

function decrease(field) {
	document.getElementById(field).value = parseInt(document.getElementById(field).value) - parseInt(document.getElementById(field + 'Increment').value);
	updateOperation()
}

function useBitRasterScroll(field) {
	var position = parseInt((document.getElementById('bitRasterInner').scrollTop / document.getElementById('bitRasterInner').scrollHeight) * bits.length);
	document.getElementById(field).value = position;
}


function takeSkip(commandString) {
	var takeSkipBits = [];
	var takeSkipCommands = [];
   
   
	var commandPositions = []
	for (let a = 0; a < commandString.length; a++) {
		if (['t','z','s','i','o','r'].includes(commandString.slice(a,a+1))) {
				commandPositions.push(a);
		}
	}
	commandPositions.push(commandString.length);
   
	var amount = 0;
	for (let b = 0; b < commandPositions.length-1; b++) {
		amount = parseInt(commandString.slice(commandPositions[b]+1, commandPositions[b+1]));
		takeSkipCommands.push( [commandString.slice(commandPositions[b],commandPositions[b]+1), amount] );
	}
   
	var c = [];
	var count = 0

	for (let i = 0; i < bits.length;) {
		c = takeSkipCommands[count % takeSkipCommands.length];

		if (c[0] == 'z') {
			takeSkipBits.push( ...Array(c[1]).fill(0) );
		} else if (c[0] == 'o') {
			takeSkipBits.push( ...Array(c[1]).fill(1) );
			count++;
		} else if (c[0] == 't') {
			takeSkipBits.push( ...bits.slice(i, i+c[1]) );
			i+=c[1];
		} else if (c[0] == 's') {
			i+=c[1];
		} else if (c[0] == 'i') {
			takeSkipBits.push( ...bits.slice(i, i+c[1]).map(invert) );
			i+=c[1];
		} else if (c[0] == 'r') {
			takeSkipBits.push( ...bits.slice(i, i+c[1]).reverse() );
			i+=c[1];
		}
		count++;
				   
	}
   
	bits = takeSkipBits;
}



function columnBias(width, checkBits) {
	//var values = [];
	var bias = 0;
	var count = 0;
	var total = 0;
	var delta = 0;
	checkBits = parseInt(checkBits);
	
	for (var i=0; i<width; i++){
		count = 0;
		total = 0;

		for (var pos = i; pos < checkBits;){
			total += bits[pos];
			pos += width;
			count += 1;
		}
		
		bias = parseFloat(total) / parseFloat(count);
		delta += Math.abs(bias - 0.5);
		
	}
	
	delta = delta / width;
	return delta / 0.5;
	////console.log(delta);
	//columnBiasArray = values;
}

function findWidth() {
	setTimeout(clearWidthGraph, 0);
	setTimeout(runFindWidth, 200);
}

function clearWidthGraph () {
	var graph = document.getElementById("findWidthGraph");
	var overlay = document.getElementById("findWidthOverlay");
	var graphWidth = parseInt(graph.parentElement.clientWidth);
	graph.width = graphWidth;
	overlay.width = graphWidth;
	
	var ctx = graph.getContext("2d");
	var text = ctx.measureText("Testing Widths...")
	ctx.clearRect(0, 0, graph.width, graph.height);
	ctx.font = "20px Helvetica";
	ctx.fillStyle = "#fff";
	ctx.fillText("Testing Widths...", (graph.width/2)-text.width, graph.height/2)-text.height;
}

var pixPerResult = 0;
var pixPerScore = 0;
var floor = 0;
var widthResults = [];
var overlayCanvas = document.getElementById("findWidthOverlay");

function applyWidth(event) {
	var rect = overlayCanvas.getBoundingClientRect();
	var x = event.clientX - rect.left;
	var y = event.clientY - rect.top;

	var min_x = parseInt((x - 4) / pixPerResult);
	var max_x = parseInt((x + 4) / pixPerResult);
	
	var bestScore = 0;
	var bestResult = 0;
	
	for (let i = min_x; i < max_x; i++) {
		if (widthResults[i][1] > bestScore) {
			bestScore = widthResults[i][1];
			bestResult = i;
		}
	}
	
	widthInput.value = bestResult;
	updateBitRaster();
	
}

function getMousePos(event) {
	var rect = overlayCanvas.getBoundingClientRect();
	var x = event.clientX - rect.left;
	var y = event.clientY - rect.top;

	var min_x = parseInt((x - 4) / pixPerResult);
	var max_x = parseInt((x + 4) / pixPerResult);
	
	var bestScore = 0;
	var bestResult = 0;
	
	for (let i = min_x; i < max_x; i++) {
		if (widthResults[i][1] > bestScore) {
			bestScore = widthResults[i][1];
			bestResult = i;
		}
	}
		
	x = bestResult * pixPerResult;
	y = overlayCanvas.height - (bestScore * pixPerScore) + floor;
	
	var ctx = overlayCanvas.getContext("2d");
	ctx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height);
	ctx.strokeStyle = "#ccccff";
	ctx.strokeRect(x-8, y-8, 16, 16);
}

function getBitLocation(event) {
	var rect = output.getBoundingClientRect();
	var x = event.clientX - rect.left;
	var y = event.clientY - rect.top;

	var width = parseInt(widthInput.value);
	var scale = parseInt(scaleInput.value);
	
	var column = parseInt(x / scale);
	var row = parseInt(y / scale);
	var bit = parseInt((row * width) + column);
	
	document.getElementById('cursorColumn').value = column;
	document.getElementById('cursorRow').value = row;
	document.getElementById('cursorBit').value = bit;

}


function singleColumnBias(column, width, checkBits) {
	var bias = 0;
	var count = 0;
	var total = 0;
	var offset = parseInt(offsetInput.value);
	checkBits = parseInt(checkBits);
	
	if (checkBits > (bits.length - offset)) {checkBits = bits.length - offset;}

	for (var pos=column; pos<checkBits;){
		total += bits[pos];
		pos += width;
		count += 1;
	}
	
	bias = parseFloat(total) / parseFloat(count);
	return bias;

}


function runColumnBias() {
	var width = parseInt(widthInput.value);
	var checkBits = parseInt(document.getElementById('columnBiasInput').value);
	
	var graph = document.getElementById("columnBiasGraph");

	var pixPerResult = graph.width / width;
	var result = 0;
	var results = [];
	var biasString = []
	
	for (var i = 0; i < width; i++) {
		result = singleColumnBias(i, width, checkBits);
		results.push([i, result]);
		biasString.push(parseInt(Math.round(result)));
	}
	
	document.getElementById('columnBiasOutput').value = biasString.join('');
	
	var ctx = graph.getContext("2d");
	ctx.clearRect(0, 0, graph.width, graph.height);
	ctx.strokeStyle = "#fff";
	ctx.beginPath();feedThruScramble
	for (var i = 0; i < results.length; i++) {
		ctx.lineTo(i*pixPerResult, graph.height-(results[i][1]*graph.height));
	}
	ctx.stroke();
}


function runFindWidth() {
	var minWidth = parseInt(document.getElementById('minWidthInput').value);
	var maxWidth = parseInt(document.getElementById('maxWidthInput').value);
	var checkBits = parseInt(document.getElementById('testBitsInput').value);
	
	var graph = document.getElementById("findWidthGraph");

	pixPerResult = graph.width / (maxWidth - minWidth);
	var maxResult = 0;
	var minResult = 1;
	var result = 0;
	widthResults = [];
	
	for (var i = minWidth; i < maxWidth; i++) {
		result = columnBias(i, checkBits);
		widthResults.push([i, result]);
		if (result > maxResult) {maxResult = result;}
		if (result < minResult) {minResult = result;}
	}
	
	var range = maxResult - minResult;
	pixPerScore = (graph.height - 1) / range;
	floor = minResult * pixPerScore;
	
	var ctx = graph.getContext("2d");
	ctx.clearRect(0, 0, graph.width, graph.height);
	ctx.strokeStyle = "#fff";
	ctx.beginPath();
	for (var i = 0; i < widthResults.length; i++) {
		ctx.lineTo(i*pixPerResult, graph.height-(widthResults[i][1]*pixPerScore)+floor);
	}
	ctx.stroke();
}

// function to open a toolbox

var openBox = "none";

function closeToolbox(item) {
	if (item == "findWidth") {
		document.getElementById('findWidthGraph').style.visibility = 'hidden';
		document.getElementById('findWidthOverlay').style.visibility = 'hidden';
	}
	
	if (item == 'columnBias') {
		document.getElementById('columnBiasGraph').style.visibility = 'hidden';
	}
	
	document.getElementById(item+"Button").style.backgroundColor = "";
	document.getElementById(item).className = "closedToolbox";
	//document.getElementById("bitRaster").className = "withClosedToolbox";
	openBox = "none";
	setTimeout(updateBitRaster, 1);
}

function openToolbox(item) {
	if (openBox == item) {
		closeToolbox(openBox);
	} else {
		if (openBox != "none") {closeToolbox(openBox);}
		openBox = item;
		document.getElementById(item+"Button").style.backgroundColor = "var(--buttonbgSelected)";
		document.getElementById(item).className = "openToolbox";
		//document.getElementById("bitRaster").className = "withOpenToolbox";
		if (item == "findWidth") {
			setTimeout(showFindWidthGraph, 1000);
			setTimeout(findWidth, 1001);
		}
		if (item == "columnBias") {
			setTimeout(showColumnBiasGraph, 1000);
			setTimeout(runColumnBias, 1001);
		}
	}
	setTimeout(updateBitRaster, 1);
}

function showFindWidthGraph() {
	document.getElementById('findWidthGraph').style.visibility = '';
	document.getElementById('findWidthOverlay').style.visibility = '';
	document.getElementById('findWidthGraph').width = document.getElementById('findWidthGraph').parentElement.clientWidth;
	document.getElementById('findWidthOverlay').width = document.getElementById('findWidthGraph').parentElement.clientWidth;
}

function showColumnBiasGraph() {
	document.getElementById('columnBiasGraph').style.visibility = '';
	document.getElementById('columnBiasGraph').width = document.getElementById('columnBiasGraph').parentElement.clientWidth;
}

// function to update the bit raster

function updateBitRaster() {
	
	if (document.getElementById('hexView').className == 'openToolbox') {
		updateHexView();
	}
	
	if (document.getElementById('asciiView').className == 'openToolbox') {
		updateAsciiView();
	}
	
	if (document.getElementById('binaryView').className == 'openToolbox') {
		updateBinaryView();
	}
	
	if (document.getElementById('columnBias').className == 'openToolbox') {
		runColumnBias();
	}
	
	var maxWidth = output.parentElement.clientWidth;
	var maxHeight = output.parentElement.clientHeight;
	
	var startX = output.parentElement.scrollLeft;
	var startY = output.parentElement.scrollTop;
	
	var endX = startX + maxWidth;
	var endY = startY + maxHeight;
		
		var width = parseInt(widthInput.value)
		var scale = parseInt(scaleInput.value)
		spacer.style.width = width * scale;
		spacer.style.height = (parseInt(bits.length / width) * scale) + scale + scale;
		output.width = maxWidth;
		output.height = maxHeight;
		output.style.top = output.parentElement.getBoundingClientRect()['y'];
		output.style.left = output.parentElement.getBoundingClientRect()['x'];
		var ctx = output.getContext("2d");
		ctx.clearRect(0, 0, output.width, output.height);
		ctx.fillStyle = '#fff';
		ctx.fillRect(0,0,output.width, output.height);

		var x = 0;
		var y = 0;
		var symbol = 0;
		
		maxX = 0;
		
		ctx.fillStyle = '#000';
		for (var i = parseInt(offsetInput.value); i < bits.length; i++) {
			if (startX <= x && x <= endX && startY <= y && y <= endY) {
				if (bits[i] == 1) { ctx.rect(x-startX, y-startY, scale, scale); }
			} 
			x += scale;
			if (x == (width*scale)) {y+=scale; x=0;}
			if (x > maxX) {maxX = x;}
		}
		ctx.fill();
		
		ctx.fillStyle = '#222';
		ctx.fillRect(maxX, 0, output.width, output.height);
		ctx.fillRect(0, y-startY+scale, output.width, output.height);
		ctx.fillRect(x-startX+scale, y-startY, output.width, output.height); 
	
}


// check page load status

if (window.FileList && window.File && window.FileReader) {
//console.log('doing the things');
updateBitRaster();

// file upload

fileSelector.addEventListener('change', event => {
	var binaryString = '';

	const file = event.target.files[0];
	const reader = new FileReader();
	reader.addEventListener('load', event => {
	
		binaryString = event.target.result;
   		var tileReader = new ByteReader( binaryString ), bitArray = [];

		while( !tileReader.EOF() ) {
			bitArray.push( tileReader.readUBits());
		}
	
		bitString = bitArray.join('').split('');
		bits = [];
		
		for (let i = 0; i < bitString.length; i++) { bits.push( parseInt( bitString[i]) ); }
		
		bitsNoOp = [...bits]
		updateBitRaster();
		
	});
	
	reader.readAsBinaryString(file);
});

// change width
document.getElementById('widthInput').addEventListener('change', event => {
	updateBitRaster();
});

// change scale
document.getElementById('scaleInput').addEventListener('change', event => {
	updateBitRaster();
});

// change offset
document.getElementById('offsetInput').addEventListener('change', event => {
	updateBitRaster();
});
}

</script>


</body></html>
