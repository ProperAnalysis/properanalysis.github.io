<html>
<head>
<title>waveView</title>
	
<style>

:root {
    --backgroundLight: #ffffff;
    --midgroundLight: #efefef;
    --borderColorLight: #8d8d8d;
    --buttonbgLight: #e5e5e5;
    --entrybgLight: #efefef;
    --backgroundLight: #e2fcff;
    --midgroundLight: #efefef;
    --borderColorLight: #2c2c2c;
    --buttonbgLight: #e2fcff;
    --entrybgLight: #ffffff;
    --buttonbgHoverLight: #54fff5;
    --buttonbgSelectedLight: #54fff5;
    --buttonfgSelectedLight: #000;
    --textColorLight: #000;
    --tableHeadColorLight: #005861;
    --tableHighlightColorLight: #910000;
    --tableHighlightColorLight2: #84006c;
    --cellColorLight: #ffffff;
    --cellBorderLight: #9e9e9e;
    --cellBorderStrongLight: #666;
    --shadowColorLight: #fff;
    --tableTopLeftLight: #fff;
    --bitRasterBgLight: #efefef;
    
    --backgroundDark: #092a30;
    --midgroundDark: #000;
    --borderColorDark: #bafbff;
    --entrybgDark: #222;
    --buttonbgDark: #003a2f;
    --buttonbgHoverDark: #009a85;
    --buttonbgSelectedDark: #00ffd1;
    --buttonfgSelectedDark: #000;
    --textColorDark: #ccfff8;
    --tableHeadColorDark: #4bffc5;
    --tableHighlightColorDark: #ff8383;
    --tableHighlightColorDark2: #e78bff;
    --cellColorDark: #050505;
    --cellBorderDark: #606060;
    --cellBorderStrongDark: #777;
    --shadowColorDark: #000;
    --tableTopLeftDark: #484848;
    --bitRasterBgDark: #222;
    
    --background: var(--backgroundDark);
    --midground: var(--midgroundDark);
    --borderColor: var(--borderColorDark);
    --buttonbg: var(--buttonbgDark);
    --entrybg: var(--entrybgDark);
    --buttonbgHover: var(--buttonbgHoverDark);
    --buttonbgSelected: var(--buttonbgSelectedDark);
    --buttonfgSelected: var(--buttonfgSelectedDark);
    --textColor: var(--textColorDark);
    --tableHeadColor: var(--tableHeadColorDark);
    --tableHighlightColor: var(--tableHighlightColorDark);
    --tableHighlightColor2: var(--tableHighlightColorDark2);
    --cellColor: var(--cellColorDark);
    --cellBorder: var(--cellBorderDark);
    --cellBorderStrong: var(--cellBorderStrongDark);
    --shadowColor: var(--shadowColorDark);
    --tableTopLeft: var(--tableTopLeftDark);
    --tableTopLeft: var(--tableTopLeftDark);
    --bitRasterBg: var(--bitRasterBgDark);
}

*::-webkit-scrollbar {
    -webkit-appearance: none;
}
*::-webkit-scrollbar:vertical {
    width: 5px;
}
*::-webkit-scrollbar:horizontal {
    height: 5px;
}
*::-webkit-scrollbar-thumb {
	border-radius: 3px;
    border: 1px solid var(--borderColor);
    background-Color: var(--buttonbg);
}
*::-webkit-scrollbar-track { 
	border-radius: 3px;
    border: none;
    background-Color: var(--midground);
} 

::-webkit-scrollbar-corner {
    background-Color: var(--midground); 
}

html, body {
	margin: 0; 
	height: 100%; 
	overflow: hidden;
	background-color: var(--background);
}


div {
	transition: max-height 0s;
}

#container {
	width: 100%;
	height: 100%;
	font-family: 'Comic Sans MS', 'Comic Sans', cursive;
	font-size: 12pt;
	color: var(--textColor);
	position: absolute;
	display: flex;
	flex-direction: column;
}


#topContainerOuter {
	height: calc(40% - 23px);
    width: calc(100% - 23px);
    margin-top: 10px;
    display: -webkit-box;
    z-index: 1;
    margin-left: 10px;
    background: var(--midground);
    border-radius: 4px;
    border: 1px solid var(--borderColor);
}

#topContainerOuterCollapsed {
	height: calc(18px);
    width: calc(100% - 23px);
    margin-top: 10px;
    display: -webkit-box;
    z-index: 1;
    margin-left: 10px;
    background: var(--midground);
    border-radius: 4px;
    border: 1px solid var(--borderColor);
    content-visibility: hidden;
}


#collapseTop {
	height: 23px;
    width: calc(100% - 23px);
    margin-top: -18px;
    display: -webkit-box;
    z-index: 1;
    margin-left: 10px;
}

#collapseTopButton {
    right: 13px;
    position: absolute;
    height: 16px;
    width: 24px;
    border: 1px solid;
}

#bottomContainerOuter {
	height: calc(60% - 23px);
    width: calc(100% - 23px);
    margin-top: 10px;
    display: -webkit-box;
    z-index: 1;
    margin-left: 10px;
    background: var(--midground);
    border-radius: 4px;
    border: 1px solid var(--borderColor);
}

#bottomContainerOuterExpanded {
	height: calc(100% - 46px);
    width: calc(100% - 23px);
    margin-top: 10px;
    display: -webkit-box;
    z-index: 1;
    margin-left: 10px;
    background: var(--midground);
    border-radius: 4px;
    border: 1px solid var(--borderColor);
}


.sideMenu {
	height: calc(100% - 20px);
	width: 150px;
	margin: 10px;
	padding-right: 10px;
	border-right: 1px solid var(--borderColor);
}

.toolbox {
	height: calc(100% - 20px);
	width: calc(100% - 190px);
	margin: 10px;
	margin-left: 0px;
}

.containerSelect {
	width: 100%;
}

.menuContainer {
	width: 100%;
	height: calc(100% - 10px - 1em);
	overflow-y: scroll;
	padding-right: 5px;
}

.tool {
	height: 100%;
	width: 100%;
	overflow-y: scroll;
	overflow-x: scroll;
}

button, input::file-selector-button, input[type="number"], input[type="text"], select{
	background-Color: var(--entrybg);
	border: 1px var(--borderColor) solid;
	border-radius: 2px;
    Color: var(--textColor);
    margin: 0px;
    font-family: "Comic Sans MS", "Comic Sans", cursive;
    outline: none;
    margin-bottom: 3px;
}

button {
	background-Color: var(--buttonbg);
}

input[type="number"], input[type="text"], select {
	width: 100%;
    font-family: "Comic Sans MS", "Comic Sans", cursive;
}

button:hover, input::file-selector-button:hover{
	background-Color: var(--buttonbgHover);
}

textArea {
	resize: none;
    background: var(--midground);
    Color: var(--textColor);
    border: none;
    padding: 0px;
    outline: none;
    font-family: monospace;
}

p {
	font-size: 10pt;
	margin: 0px;
}

table {
	font-size: 10pt;
	color: white;
	width: 100%;
}

.toolHidden {
	display: none;
}

.sideMenuItemHidden {
	display: none;
}

</style>	
	
</head>



<body>
<div id='container'>

<div id='topContainerOuter'>
	<div class='sideMenu'>
		<select id='topContainerSelect' class='containerSelect'>
		</select>
		<div id='topContainerMenu' class='menuContainer'>
		
<div id='Input Select Menu' class='sideMenuItemHidden'>
</div>
<div id='PSK Demodulate Menu' class='sideMenuItemHidden'>
</div>

<div id='FSK Demodulate Menu' class='sideMenuItemHidden'>
</div>

<div id='FIR Filter Menu' class='sideMenuItemHidden'>
</div>

		</div>
	</div>
	<div class='toolbox' id='topContainer'>
	
<div id='Input Select' class='toolHidden' updateFunction='noUpdate()'>
Select Input Source
<table>
<tr><td style="width:30%;">Sample Rate:</td><td><input type='number' id='sampleRate' value=8000></td></tr>
<tr><td>Bits Per Sample:</td><td><input type='number' id='bitsPerSample' value=8></td></tr>
<tr><td>Header Length (Bytes):</td><td><input type='number' id='headerLen' value=44></td></tr>
<tr><td></td><td></td></tr>
<tr><td colspan=2><input type="file" id="fileSelector" onchange='readFile()'></td></tr>
</table>
</div>

<div id='PSK Demodulate' class='toolHidden' updateFunction='noUpdate()'>
Demodulate Phase Shift Keying
<table>
<tr><td style="width:30%;">Frequency:</td><td><input type='number' id='pskDemodulateFrequency' value=2000></td></tr>
<tr><td>Phase:</td><td><input type='number' id='pskDemodulatePhase' value=0></td></tr>
<tr><td>Start Sample:</td><td><input type='number' id='pskDemodulateStart' value=0></td></tr>
<tr><td>Averaging Window:</td><td><input type='number' id='pskDemodulateAveraging' value=16 min='1'></td></tr>
<tr><td>Symbol Rate:</td><td><input type='number' id='pskDemodulateSymbolRate' value=0></td></tr>
<tr><td>Symbol Thresholds:</td><td><input type='text' id='pskDemodulateThresholds' value=''></td></tr>
<tr><td>Symbol Mapping:</td><td><input type='text' id='pskDemodulateSym2Bit' value=''></td></tr>
<tr><td></td><td><button onclick='pskDemodulate()'>Apply Demodulation</button> <button onclick='pskDemodulateUndo()'>Undo Demodulation</button></td></tr>
</table>
</div>

<div id='FSK Demodulate' class='toolHidden' updateFunction='noUpdate()'>
Demodulate Frequency Shift Keying
<table>
<tr><td style="width:30%;">Start Sample:</td><td><input type='number' id='fskDemodulateStart' value=0 min='0'></td></tr>
<tr><td>Averaging Window:</td><td><input type='number' id='fskDemodulateAveraging' value=16 min='1'></td></tr>
<tr><td>Measurement Cross:</td><td><input type='number' id='fskDemodulateCrossPoint' value=0></td></tr>
<tr><td>Symbol Rate:</td><td><input type='number' id='fskDemodulateSymbolRate' value=0 min='0'></td></tr>
<tr><td>Symbol Thresholds:</td><td><input type='text' id='fskDemodulateThresholds' value=''></td></tr>
<tr><td>Symbol Mapping:</td><td><input type='text' id='fskDemodulateSym2Bit' value=''></td></tr>
<tr><td></td><td><button onclick='fskDemodulate()'>Apply Demodulation</button> <button onclick='fskDemodulateUndo()'>Undo Demodulation</button></td></tr>
</table>
</div>

<div id='FIR Filter' class='toolHidden' updateFunction='noUpdate()'>
Apply FIR Filter
<p>&nbsp;</p>
<p>Filter Coefficients:</p>
<textArea style='border: 1px solid var(--borderColor); margin-top: 10px; margin-bottom: 10px; width: 100%; height: 50%;' id='firFilterCoefs'></textArea>
<p><button onclick='applyFIR()'>Apply Filter</button> <button onclick='removeFIR()'>Remove Filter</button>
</div>

	
	</div>
</div>

<div id='collapseTop'><button id='collapseTopButton' onclick='collapseTopContainer()'>^</button></div>

<div id='bottomContainerOuter'>
	<div class='sideMenu'>
		<select id='bottomContainerSelect' class='containerSelect'>
		</select>
		<div id='bottomContainerMenu' class='menuContainer'>
		
<div id='Frequency Domain Menu' class='sideMenuItemHidden'>
<p>Start Sample: <input id='frequencyDomainStartSample' type='number' value=0 onchange='updateFrequencyDomain()'></p>
<p>Averages: <input id='frequencyDomainAverages' type='number' value=1 onchange='updateFrequencyDomain()'></p>
<p>FFT Length:
<select id='frequencyDomainFFTlen' onchange='updateFrequencyDomain()'>
<option value=256>256</option>
<option value=512>512</option>
<option value=1024>1024</option>
<option selected value=2048>2048</option>
<option value=4096>4096</option>
<option value=8192>8192</option>
<option value=16384>16384</option>
<option value=32768>32768</option>
<option value=65536>65536</option>
</select>
</p>
<p>Window Function:
<select id='frequencyDomainWindowFunction' onchange='updateFrequencyDomain()'>
<option value='hamming'>Hamming</option>
<option value='blackmanHarris'>Blackman-Harris</option>
<option value='blackmanNuttall'>Blackman-Nuttall</option>
<option value='hann'>Hann</option>
<option value='rectangular'>Rectangular</option>
</select>
</p>
<p>Advanced Functions:
<select id='frequencyDomainAdvancedFunction' onchange='updateFrequencyDomain()'>
<option value='noFunction'>None</option>
<option value='movingAverageDelta'>Moving Average Delta</option>
</select>
</p>
<p>Frequency Marker: <input id='frequencyDomainXmarker' type='number' min=0 value=0 onchange='updateFrequencyDomain()'></p>
<p>Display Grids:
<select id='frequencyDomainGridsOn' onchange='updateFrequencyDomain()'>
<option value='true'>Yes</option>
<option value='false'>No</option>
</select>
</p>
<p>Animation Rate (samples/second): <input id='frequencyDomainAnimationRate' type='number' value=8000></p>
<p><button onclick='stopStartAnimateFrequencyDomain()'>Animate / Stop</button></p>
</div>

<div id='Symbol Rate View Menu' class='sideMenuItem'>
<p>Start Sample: <input id='symbolRateViewStartSample' type='number' value=0 onchange='updateSymbolRateView()'></p>
<p>End Sample: <input id='symbolRateViewEndSample' type='number' value=8000 onchange='updateSymbolRateView()'></p>
<p>Max Symbol Rate: <input id='symbolRateViewMaxFrequency' type='number' value=2000 onchange='updateSymbolRateView()'></p>
<p>Symbol Rate Marker: <input id='symbolRateViewXmarker' type='number' min=0 value=0 onchange='updateSymbolRateView()'></p>
<p>Display Grids:
<select id='symbolRateViewGridsOn' onchange='updateSymbolRateView()'>
<option value='true'>Yes</option>
<option value='false'>No</option>
</select>
</p>
</div>


<div id='Spectrogram Menu' class='sideMenuItemHidden'>
<p>Start Sample: <input type='number' id='spectroStartSample' value=0 onchange='updateSpectrogram()'></p>
<p>End Sample: <input type='number' id='spectroEndSample' value=64000 onchange='updateSpectrogram()'></p>
<p>FFT Length:
<select id='spectroFFTlen' onchange='updateSpectrogram()'>
<option value=16>16</option>
<option value=32>32</option>
<option selected value=64>64</option>
<option value=128>128</option>
<option value=256>256</option>
<option value=512>512</option>
<option value=1024>1024</option>
<option value=2048>2048</option>
<option value=4096>4096</option>
<option value=8192>8192</option>
<option value=16384>16384</option>
</select>
</p>
<p>FFT Overlap:
<select id='spectroFFTratio' onchange='updateSpectrogram()'>
<option selected value=1>1</option>
<option value=2>2</option>
<option value=4>4</option>
<option value=8>8</option>
<option value=16>16</option>
<option value=32>32</option>
</select>
</p>

<p>Window Function:
<select id='spectroWindowFunction' onchange='updateSpectrogram()'>
<option value='hamming'>Hamming</option>
<option value='blackmanHarris'>Blackman-Harris</option>
<option value='blackmanNuttall'>Blackman-Nuttall</option>
<option value='hann'>Hann</option>
<option value='rectangular'>Rectangular</option>
</select>
</p>

<p>Grids / Second: <input type='number' id='spectroGridRate' value=0 onchange='updateSpectrogram()'></p>
<p>Grid Offset: <input type='number' id='spectroGridOffset' value=0 onchange='updateSpectrogram()'></p>
<p><button onclick='nextSpectrogram()'>Slide Forward</button></p>
<p><button onclick='previousSpectrogram()'>Slide Back</button></p>
</div>

<div id='Time Domain Menu' class='sideMenuItemHidden'>
<p>Start Sample: <input type='number' id='timeDomainStartSample' value=0 onchange='updateTimeDomain()'></p>
<p>End Sample: <input type='number' id='timeDomainEndSample' value=2000 onchange='updateTimeDomain()'></p>
<p>Grids / Second: <input type='number' id='timeDomainGridRate' value=0 min=0 onchange='updateTimeDomain()'></p>
<p>Grid Offset: <input type='number' id='timeDomainGridOffset' value=0 min=0 onchange='updateTimeDomain()'></p>
<p>Y Max: <input type='number' id='timeDomainYmax' value=100 onchange='updateTimeDomain()'></p>
<p>Y Min: <input type='number' id='timeDomainYmin' value=-100 onchange='updateTimeDomain()'></p>
<p>Y Scale:
<select id='timeDomainAutoY' onchange='updateTimeDomain()'>
<option value='true'>Auto</option>
<option value='false'>Manual</option>
</select>
</p>
<p>Y Marker: <input type='number' id='timeDomainYmarker' value=0 onchange='updateTimeDomain()'></p>
<p>Style:
<select id='timeDomainStyle' onchange='updateTimeDomain()'>
<option value='line'>Line</option>
<option value='points'>Points</option>
<option value='both'>Line+Points</option>
<option value='comparison'>Demod Comparison</option>
</select>
</p>
<p><button onclick='stopStartAnimateTimeDomain()'>Animate / Stop</button></p>
</div>

<div id='Bit Raster Menu' class='sideMenuItemHidden'>
<p>Start Sample: <input type='number' id='bitRasterStartSample' value=0 onchange='updateBitRaster()'></p>
<p>Raster Width: <input type='number' id='bitRasterWidth' value=256 onchange='updateBitRaster()'></p>
<p>Raster Scale: <input type='number' id='bitRasterScale' value=2 onchange='updateBitRaster()'></p>
<p>1/0 Threshold: <input type='number' id='bitRasterThresh' value=50 onchange='updateBitRaster()'></p>
<p><button onclick='updateBitRaster()'>Update</button></p>
</div>

<div id='Binary Output Menu' class='sideMenuItemHidden'>
</div>
		
		</div>
	</div>
	<div class='toolbox' id='bottomContainer'>
	
<div id='Time Domain' class='toolHidden' updateFunction='updateTimeDomain()'>
<canvas id='timeDomainCanvas'>
</div>

<div id='Frequency Domain' class='toolHidden' updateFunction='updateFrequencyDomain()'>
<canvas id='frequencyDomainCanvas'>
</div>

<div id='Symbol Rate View' class='toolHidden' updateFunction='updateSymbolRateView()'>
<canvas id='symbolRateViewCanvas'>
</div>

<div id='Spectrogram' class='toolHidden' updateFunction='updateSpectrogram()'>
<canvas style='filter: hue-rotate(280deg);' id='spectroCanvas'>
</div>

<div id='Bit Raster' class='toolHidden' updateFunction='updateBitRaster()'>
<canvas id='bitRasterCanvas' style='background: #222;'>
</div>

<div id='Binary Output' class='toolHidden' updateFunction='updateBinaryOutput()'>
<textArea style='width: 100%; height: 100%;' id='binaryOutputTextArea'></textArea>
</div>
	
	</div>
</div>

</div>

</body>
</html>

<script src="math.js" type="text/javascript"></script>

<script>

function $ (elementId) {
	return document.getElementById(elementId)
}

function option (name) {
	var opt = document.createElement('option')
    opt.value = name
    opt.innerHTML = name
    return opt
}

function updateToolSelection() {
	for (let i=0; i<$('topContainer').children.length; i++) {
		topContainerSelect.appendChild( option( $('topContainer').children[i].id ) )
	}
	
	for (let i=0; i<$('bottomContainer').children.length; i++) {
		bottomContainerSelect.appendChild( option( $('bottomContainer').children[i].id ) )
	}
	
	$('topContainerSelect').value = 'Input Select'
	$('Input Select').className = 'tool'
	$('Input Select Menu').className = 'sideMenuItem'

	$('bottomContainerSelect').value = 'Time Domain'
	$('Time Domain').className = 'tool'
	$('Time Domain Menu').className = 'sideMenuItem'
	updateUIfunction = $('Time Domain').attributes.updatefunction.value
	
}


function topToolSelection(event) {
	for (let i=0; i<$('topContainer').children.length; i++) {
		$('topContainer').children[i].className = 'toolHidden'
		console.log($('topContainer').children[i].id + ' Menu')
		$($('topContainer').children[i].id + ' Menu').className = 'sideMenuItemHidden'
	}

	let selection = event.srcElement.value;
	$(selection).className = 'tool'
	$(selection+' Menu').className = 'sideMenuItem'
}

function bottomToolSelection(event) {
	for (let i=0; i<$('bottomContainer').children.length; i++) {
		$('bottomContainer').children[i].className = 'toolHidden'
		$($('bottomContainer').children[i].id + ' Menu').className = 'sideMenuItemHidden'
	}

	let selection = event.srcElement.value;
	$(selection).className = 'tool'
	$(selection+' Menu').className = 'sideMenuItem'
	updateUIfunction = $(selection).attributes.updatefunction.value
	updateUI()
}

function toFloat(INT) {
	return (INT - 127.0) / 127.0
}

function readFile() {
	var file = new Blob([$('fileSelector').files[0]])
	var reader = new FileReader()
	var fileByteArray = []
	reader.readAsArrayBuffer(file)
	reader.onloadend = function (evt) {
    	if (evt.target.readyState == FileReader.DONE) {
       		var arrayBuffer = evt.target.result,
           	array = new Uint8Array(arrayBuffer);
       		for (var i = 0; i < array.length; i++) {
           		fileByteArray.push(array[i]);
        	}
    	}
    }
    inputData = fileByteArray
    setTimeout( parseInputData, 100)
}

function parseInputData() {
	let headerLen = parseInt($('headerLen').value)
	let bitsPerSample = parseInt($('bitsPerSample').value)
	inputData = inputData.slice(headerLen, inputData.len)
	
	if (bitsPerSample == 8) {
		inputData = inputData.map(toFloat)
	}
	inputDataNoOp = [...inputData]
	updateUI()
}

var updateUIfunction = null
function updateUI() {
	eval( updateUIfunction )
}

function noUpdate() {
	console.log('no update')
}

var animatingTimeDomain = false
var animateTimeDomainSpeed = 0
function stopStartAnimateTimeDomain() {
	if (animatingTimeDomain) {
		animatingTimeDomain = false
	} else {
		animateTimeDomainSpeed = (parseInt($('timeDomainEndSample').value) - parseInt($('timeDomainStartSample').value)) / 100
		animatingTimeDomain = true
		animateTimeDomain()
	}
}

function animateTimeDomain() {
	if (animatingTimeDomain) {
		$('timeDomainStartSample').value = parseInt($('timeDomainStartSample').value) + animateTimeDomainSpeed
		$('timeDomainEndSample').value = parseInt($('timeDomainEndSample').value) + animateTimeDomainSpeed
		$('timeDomainGridOffset').value = parseInt($('timeDomainGridOffset').value) + animateTimeDomainSpeed
		updateTimeDomain()
		setTimeout(animateTimeDomain, 33);
	} else {
		return null
	}
}

function updateTimeDomain() {
	let canvas = $('timeDomainCanvas')
	let ctx = canvas.getContext('2d')
	let minSample = parseInt( $('timeDomainStartSample').value )
	let maxSample = parseInt( $('timeDomainEndSample').value )
	let yMax = parseFloat( $('timeDomainYmax').value ) / 100
	let yMin = parseFloat( $('timeDomainYmin').value ) / 100
	let yMarker = parseFloat( $('timeDomainYmarker').value ) / 100
	let style = $('timeDomainStyle').value
	let samples = maxSample - minSample
	let autoY = eval($('timeDomainAutoY').value)
	
	if (maxSample <= minSample) { return null }
	if (autoY) {
		yMax = math.max(inputData) * 1.1
		yMin = math.min(inputData) * 1.1
		if (yMax == 0) { yMax = 0.1 }
		if (yMin == 0) { yMin = -0.1 }
		$('timeDomainYmax').value = yMax * 100
		$('timeDomainYmin').value = yMin * 100
	}
	
	let range = yMax - yMin
	
	canvas.width = canvas.parentElement.clientWidth;
	canvas.height = canvas.parentElement.clientHeight;
	let pw = canvas.width / samples
	let ph = canvas.height / range
	
	let gridSpacing = sampleRate / parseInt( $('timeDomainGridRate').value )
	let gridOffset =  parseInt(parseInt( $('timeDomainGridOffset').value ) * pw)
	let gridSize = 0
	
	if (gridSpacing == 0) {
		gridSize = canvas.width
	} else {
		gridSize = canvas.width / (samples / gridSpacing)
	}
	
	ctx.fillStyle = "#333"
	
	let i = 0
	for (let x = gridOffset; x < canvas.width;) {
		if (i % 2 == 1) {
			ctx.fillRect(x,0,gridSize,canvas.height)
		}
		i++
		x += gridSize
	}
	
	ctx.beginPath()
	ctx.strokeStyle = "red"
	ctx.moveTo(0, canvas.height - ((yMarker - yMin) * (ph) ))
	ctx.lineTo(canvas.width, canvas.height - ((yMarker - yMin) * (ph) ))
	ctx.stroke()


	if (style == 'line') {
		
		ctx.beginPath()
		ctx.strokeStyle = "white"
		ctx.moveTo(0, ph)
	
		let x = 0
		for (let s = minSample; s < maxSample; s++) {
			let y = canvas.height - ((inputData[s] - yMin) * (ph) )
			ctx.lineTo(x, y)
			x += pw
		}
		ctx.stroke()
		
	} else if (style == 'points') {
		ctx.fillStyle = "white"
		let x = 0
		for (let s = minSample; s < maxSample; s++) {
			let y = canvas.height - ((inputData[s] - yMin) * (ph) )
			ctx.fillRect(x,y,2,2)
			x += pw
		}
	
	} else if (style == 'both') {
	
		ctx.fillStyle = "yellow"
		ctx.beginPath()
		ctx.strokeStyle = "white"
		ctx.moveTo(0, ph)
	
		let x = 0
		for (let s = minSample; s < maxSample; s++) {
			let y = canvas.height - ((inputData[s] - yMin) * (ph) )
			ctx.lineTo(x, y)
			ctx.fillRect(x,y,2,2)
			x += pw
		}
		ctx.stroke()
	
	} else if (style == 'comparison') {
		ctx.beginPath()
		ctx.strokeStyle = "#999"
		ctx.moveTo(0, ph)
	
		let x = 0
		for (let s = minSample; s < maxSample; s++) {
			let y = canvas.height - ((inputDataNoOp[s] - yMin) * (ph) )
			ctx.lineTo(x, y)
			x += pw
		}
		ctx.stroke()
		
		ctx.beginPath()
		ctx.strokeStyle = "yellow"
		ctx.moveTo(0, ph)
		
		x = 0
		for (let s = minSample; s < maxSample; s++) {
			let y = canvas.height - ((inputData[s] - yMin) * (ph) )
			ctx.lineTo(x, y)
			x += pw
		}
		ctx.stroke()
	}
	

}

function updateBitRaster() {
	let canvas = $('bitRasterCanvas')
	let ctx = canvas.getContext('2d')
	let startSample = parseInt( $('bitRasterStartSample').value )
	let rasterWidth = parseInt( $('bitRasterWidth').value )
	let scale = parseInt( $('bitRasterScale').value )
	let rasterThresh = parseFloat( $('bitRasterThresh').value ) / 100
	
	canvas.width = canvas.parentElement.clientWidth;
	canvas.height = canvas.parentElement.clientHeight;

	let x = 0
	let y = 0
	for (let s = startSample; s < inputData.length; s++) {
		if (inputData[s] > rasterThresh) { ctx.fillStyle = '#000' }
		else { ctx.fillStyle = '#fff' }
		
		ctx.fillRect(x*scale,y*scale,scale,scale)
	
		x += 1
		if (x == rasterWidth) {
			y += 1
			x = 0
		}
		
		if ((y * scale) > canvas.height) { return null }
		
	}
}

function nextSpectrogram() {
	let range = parseInt($('spectroEndSample').value) - parseInt($('spectroStartSample').value)
	$('spectroEndSample').value = parseInt($('spectroEndSample').value) + parseInt(range/2)
	$('spectroStartSample').value =  parseInt($('spectroStartSample').value) + parseInt(range/2)
	updateSpectrogram()	
}

function previousSpectrogram() {
	let range = parseInt($('spectroEndSample').value) - parseInt($('spectroStartSample').value)
	$('spectroEndSample').value = parseInt($('spectroEndSample').value) - parseInt(range/2)
	$('spectroStartSample').value =  parseInt($('spectroStartSample').value) - parseInt(range/2)
	updateSpectrogram()	
}

function updateSpectrogram() {
	let canvas = $('spectroCanvas')
	let ctx = canvas.getContext('2d')
	ctx.translate(0.1, 0.1)
	ctx.imageSmoothingEnabled= false
	let fftLen = parseInt( $('spectroFFTlen').value )
	let startSample = parseInt( $('spectroStartSample').value )
	let endSample = parseInt( $('spectroEndSample').value )
	let FFTratio = parseInt( $('spectroFFTratio').value )
	let windowFunction = eval( $('spectroWindowFunction').value )
	
	if (endSample <= startSample) { return null }
	
	if (endSample > inputData.length) { endSample = inputData.length-fftLen }
	let duration = endSample - startSample

	canvas.width = canvas.parentElement.clientWidth;
	canvas.height = canvas.parentElement.clientHeight;
	
	let spectrogram = new Array()
	let scalingFactor = 2 / (sampleRate * fftLen)
	let step = 0
	let samplesPerStep = ( (fftLen) / FFTratio )
	
	let min = 1000
	let max = -1000
	
	while (step < (duration-(fftLen*2))) {
		let psds = new Array(fftLen).fill(0)
		let samples = inputData.slice(startSample+step, startSample+step+(fftLen*2))
		samples = applyWindow(samples, windowFunction)
		let ffts = math.fft(samples)
		
		for (let x = 1; x < (fftLen)-1; x++) {
			let magnitude = 1 + math.sqrt( math.pow(ffts[x].re, 2) +  math.pow(ffts[x].im, 2) )
			let power = scalingFactor * math.pow(magnitude, 2)
			psds[x] = ( math.log(power, 10) )
			if (psds[x] > max) { max = psds[x] }
			if (psds[x] < min) { min = psds[x] }
		}
	
		spectrogram.push([...psds.slice(1,-1)])
		step+=samplesPerStep
	}
	
	canvas.width = spectrogram.length
	let ph = canvas.height / spectrogram[0].length
	
	let range = max - min
	let scaling = 255 / range
	
	for (let x = 0; x < spectrogram.length; x++) {
		for (let y = 0; y < spectrogram[0].length; y++) {
			ctx.fillStyle = cmap[ parseInt((spectrogram[x][y]-min)*scaling) ]
			ctx.fillRect(x, parseInt(canvas.height - y*ph), x+1, parseInt(ph)+1)
		}
	}
	
	let gridSpacing = parseFloat( $('spectroGridRate').value )
	let gridOffset =  parseInt( $('spectroGridOffset').value ) * -1
	let gridSize = 0
	
	if (gridSpacing == 0) {
		gridSize = canvas.width
	} else {
		gridSize = ( (sampleRate / gridSpacing) / samplesPerStep )
	}
	
	ctx.strokeStyle = '#ff0'
	for (let x = gridOffset; x < canvas.width; x += gridSize) {
			ctx.moveTo(x, 0)
			ctx.lineTo(x, canvas.height)
			ctx.stroke()
	}

	
}

var animatingFrequencyDomain = false
var animateFrequencyDomainSpeed = 0
function stopStartAnimateFrequencyDomain() {
	if (animatingFrequencyDomain) {
		animatingFrequencyDomain = false
	} else {
		animateFrequencyDomainSpeed = parseInt($('frequencyDomainAnimationRate').value) * (33/1000)
		animatingFrequencyDomain = true
		animateFrequencyDomain()
	}
}

function animateFrequencyDomain() {
	if (animatingFrequencyDomain) {
		if ( parseInt($('frequencyDomainStartSample').value) + animateFrequencyDomainSpeed >= inputData.length ) {
			animatingFrequencyDomain = false
			$('frequencyDomainStartSample').value = inputData.length - ( parseInt( $('frequencyDomainFFTlen').value ) * parseInt( $('frequencyDomainAverages').value ) ) - 1
			updateFrequencyDomain()
			return null
		}
		$('frequencyDomainStartSample').value = parseInt($('frequencyDomainStartSample').value) + animateFrequencyDomainSpeed
		updateFrequencyDomain()
		setTimeout(animateFrequencyDomain, 33);
	} else {
		return null
	}
}

function updateBinaryOutput() {
	let textArea = $('binaryOutputTextArea')
	textArea.value = inputData.join('')
}

function updateFrequencyDomain() {
	let canvas = $('frequencyDomainCanvas')
	let ctx = canvas.getContext('2d')
	let fftLen = parseInt( $('frequencyDomainFFTlen').value )
	let startSample = parseInt( $('frequencyDomainStartSample').value )
	let averages = parseInt( $('frequencyDomainAverages').value )
	let xMarker = parseInt( $('frequencyDomainXmarker').value )
	let windowFunction = eval( $('frequencyDomainWindowFunction').value )
	let gridsOn = eval( $('frequencyDomainGridsOn').value )
	let advancedFunction = eval( $('frequencyDomainAdvancedFunction').value )
	
	let psds = new Array(fftLen/2).fill(0)
	let scalingFactor = 2 / (sampleRate * fftLen)
	
	let samples = [...inputData.slice(startSample, 1+startSample+(averages*fftLen))]
	if (samples.length < averages*fftLen) { return null }
	
	console.log(samples)
		
	for (let i = 0; i<(samples.length-fftLen); i+=fftLen) {
		let fftSamples = applyWindow(samples.slice(i,i+fftLen), windowFunction)
		let ffts = math.fft(fftSamples)
		for (let x = 1; x < (fftLen/2)-1; x++) {
			let magnitude = 1 + math.sqrt( math.pow(ffts[x].re, 2) +  math.pow(ffts[x].im, 2) )
			let power = scalingFactor * math.pow(magnitude, 2)
			psds[x] = ( math.log(power, 10) )
		}
	}
	
	for (let p = 0; p < psds.length; p++) {
		psds[p] = psds[p] * (1/averages)
	}
	
	psds = psds.slice(1,-1)
	psds = advancedFunction(psds)
	
	let maxY = math.max(psds)
	let minY = math.min(psds)
	let range = maxY - minY
	
	canvas.width = canvas.parentElement.clientWidth;
	canvas.height = canvas.parentElement.clientHeight;
	let scaleWidth = 30
	let scaleHeight = 20
	let width = canvas.width - scaleWidth
	let height = canvas.height - scaleHeight
	let pw = width / psds.length
	let ph = height / range
		
	ctx.fillStyle = '#bafbff'
	ctx.fillRect(0, height, width, 1)
	
	let tickRate = parseInt( (sampleRate / 2) / 10 )
	let tick = 0
	ctx.font = "12px Monospace";
	ctx.fillStyle = '#bafbff'
	ctx.fillRect(0, height-5, 1, scaleHeight+5)
	ctx.fillText("0 Hz", 3, height+scaleHeight);
	tick += tickRate

	while (tick < sampleRate/2) {
		let x = (tick / ((sampleRate/2)/psds.length) ) * pw
		ctx.fillStyle = '#333'
		ctx.fillRect(x, 0, 1, height)
		ctx.fillStyle = '#bafbff'
		ctx.fillRect(x, height-5, 1, scaleHeight+5)
		ctx.fillText(tick, x+3, height+scaleHeight-2);
		tick += tickRate
	}
	ctx.fillStyle = '#bafbff'
	ctx.fillRect(width, 0, 1, height)
	
	tickRate = range / 10.0
	tick = tickRate

	while (tick <= range+(tickRate/2)) {
		let y = (tick / range ) * height
		ctx.fillStyle = '#333'
		ctx.fillRect(0, canvas.height-y, width, 1)
		ctx.fillStyle = '#bafbff'
		ctx.fillRect(width-5, canvas.height-y, 10, 1)
		ctx.fillText(tick.toFixed(1), width+6, canvas.height-y+5);
		tick += tickRate
	}
	ctx.fillText('~dB', width+6, 12);
	
	if (xMarker < 1) {xMarker = sampleRate}
	xMarker = (xMarker / ((sampleRate/2)/psds.length) ) * pw
	ctx.beginPath()
	ctx.strokeStyle = "red"
	ctx.moveTo(xMarker, 0)
	ctx.lineTo(xMarker, canvas.height)
	ctx.stroke()
	
	if (gridsOn) {
		console.log('grids on')
		console.log(xMarker)
		ctx.beginPath()
		ctx.strokeStyle = "red"
		let x = xMarker
		while (x < width) {
			ctx.moveTo(x, 0)
			ctx.lineTo(x, height)
			x+= xMarker
		}	
		ctx.stroke()
	}
	
	ctx.beginPath()
	ctx.strokeStyle = "white"
	ctx.moveTo(0, ph)

	let x = 0
	for (let s = 0; s < psds.length; s++) {
		let y = height - ( ( psds[s] - minY ) * ph )
		ctx.lineTo(x, y)
		x += pw
	}
	
	ctx.stroke()
}

function updateSymbolRateView() {
	let canvas = $('symbolRateViewCanvas')
	let ctx = canvas.getContext('2d')
	let startSample = parseInt( $('symbolRateViewStartSample').value )
	let endSample = parseInt( $('symbolRateViewEndSample').value )
	let xMarker = parseInt( $('symbolRateViewXmarker').value )
	let gridsOn = eval( $('symbolRateViewGridsOn').value )
	let maxFrequency = parseInt( $('symbolRateViewMaxFrequency').value )
	
	let samples = [...inputData.slice(startSample, endSample)]
	let results = new Array(sampleRate+1).fill(0)
	
	let lastValue = 0
	let runLength = 1
	for (let i=0; i<samples.length; i++) {
		if (samples[i] == lastValue) {
			runLength++
		} else {
			results[parseInt(sampleRate/runLength)] += 1
			runLength = 1
			lastValue = samples[i]
		}
	}
	
	results = results.slice(1, maxFrequency+1)
	
	let maxY = math.max(results)
	let minY = math.min(results)
	let range = maxY - minY
	if (range == 0) {range = 1}
	
	canvas.width = canvas.parentElement.clientWidth;
	canvas.height = canvas.parentElement.clientHeight;
	let scaleWidth = 30
	let scaleHeight = 20
	let width = canvas.width - scaleWidth
	let height = canvas.height - scaleHeight
	let pw = width / results.length
	let ph = height / range
		
	ctx.fillStyle = '#bafbff'
	ctx.fillRect(0, height, width, 1)
	
	let tickRate = parseInt( results.length / 10 )
	let tick = 0
	ctx.font = "12px Monospace";
	ctx.fillStyle = '#bafbff'
	ctx.fillRect(0, height-5, 1, scaleHeight+5)
	ctx.fillText("0 Hz", 3, height+scaleHeight);
	tick += tickRate

	while (tick < results.length) {
		let x = tick * pw
		ctx.fillStyle = '#333'
		ctx.fillRect(x, 0, 1, height)
		ctx.fillStyle = '#bafbff'
		ctx.fillRect(x, height-5, 1, scaleHeight+5)
		ctx.fillText(tick, x+3, height+scaleHeight-2);
		tick += tickRate
	}
	ctx.fillStyle = '#bafbff'
	ctx.fillRect(width, 0, 1, height)
	
	tickRate = range / 10.0
	tick = tickRate

	while (tick <= range+(tickRate/2)) {
		let y = (tick / range ) * height
		ctx.fillStyle = '#333'
		ctx.fillRect(0, canvas.height-y, width, 1)
		ctx.fillStyle = '#bafbff'
		ctx.fillRect(width-5, canvas.height-y, 10, 1)
		ctx.fillText(tick.toFixed(1), width+6, canvas.height-y+5);
		tick += tickRate
	}
	ctx.fillText('#', width+6, 12);
	
	if (xMarker < 1) {xMarker = maxFrequency*2}
	let x1 = xMarker * pw
	xMarker = xMarker * pw
	ctx.beginPath()
	ctx.strokeStyle = "red"
	ctx.moveTo(xMarker, 0)
	ctx.lineTo(xMarker, canvas.height)
	ctx.stroke()
	
	if (gridsOn) {
		console.log('grids on')
		console.log(xMarker)
		ctx.beginPath()
		ctx.strokeStyle = "red"
		let x = xMarker
		while (x < width) {
			ctx.moveTo(x, 0)
			ctx.lineTo(x, height)
			x+= xMarker
		}	
		ctx.stroke()
	}
	
	ctx.beginPath()
	ctx.strokeStyle = "white"
	ctx.moveTo(0, ph)

	let x = pw
	for (let s = 0; s < results.length; s++) {
		let y = height - ( ( results[s] - minY ) * ph )
		ctx.lineTo(x, y)
		x += pw
	}
	
	ctx.stroke()
	
}

function noFunction(samples) {
	return samples
}

function movingAverageDelta(samples) {
	console.log(samples)
	let average = 0
	let newSamples = new Array(samples.length).fill(0)
	let windowLen = 10
	
	for (let i=0; i<windowLen; i++) {
		samples.push( samples[samples.length-1] )
	}
	
	console.log(samples.length)
	console.log(newSamples.length)
	for (let i=0; i<newSamples.length; i++) {
		newSamples[i] = samples[i] - math.mean( samples.slice(i,i+windowLen) )	
	}
	
	return newSamples

}

function validateThresholds(thresholds) {
	let valids = []
	for (let i = 0; i < thresholds.length ; i++) {
		let t = parseFloat(thresholds[i])
		if (isNaN(t) == false) { 
			if (t == 0) { valids.push(t) }
			else { valids.push(t/100) }
		}
	}
	return valids
}

function validateBits(sym2bit) {
	let valids = []
	for (let i = 0; i < sym2bit.length ; i++) {
		let t = sym2bit[i].split('').map(makeInt)
		if (t.length != 0) { valids.push(t) }
	}
	return valids
}

function pskDemodulateUndo() {
	inputData = inputDataNoOp
	updateUI()
}

function pskDemodulate() {

	let frequency = parseFloat($('pskDemodulateFrequency').value)
	let phase = parseFloat($('pskDemodulatePhase').value) / 360.0
	let averagingWindow = parseFloat($('pskDemodulateAveraging').value)
	let symbolRate = parseFloat($('pskDemodulateSymbolRate').value)
	let startSample = parseInt($('pskDemodulateStart').value)
	let thresholds = $('pskDemodulateThresholds').value.split(',')
	let sym2bit = $('pskDemodulateSym2Bit').value.split(',')
	thresholds = validateThresholds(thresholds)
	sym2bit = validateBits(sym2bit)

	var period = sampleRate / frequency
	var duration = inputDataNoOp.length - startSample
	
	if(frequency == 0) {
		inputData = [...inputDataNoOp.slice(startSample,inputDataNoOp.length)]
		updateUI()
		return null
	}
	
	let symbolWindow = 1
	if (symbolRate > 0) { symbolWindow = sampleRate / symbolRate }

	let samples = new Array()
	
	for (let i = 0; i<(averagingWindow/2); i++) {
		samples.push( inputDataNoOp[0] )
	}
	
	let windowLen = period / 8
	if (windowLen < 1) { windowLen = 1 }
	for (let j = period*phase; j < duration + (period*phase);) { 
		for (let i=0; i<period; i++) {
			samples.push( math.mean( inputDataNoOp.slice( parseInt(j), parseInt( j+windowLen ) ) ) )
		}
		j += period
    }
    
    let averageSample = math.mean(samples)
    let maxSample = math.max(samples)
    let minSample = math.min(samples)
    let rangeSamples = maxSample - minSample
    let scale = 4 / rangeSamples
    
    for (let i = 0; i<samples.length-averagingWindow; i++) {
    	samples[i] = (samples[i] - averageSample) * scale
    }
    
    if (averagingWindow > 1) {
    for (let i = 0; i<samples.length-averagingWindow; i++) {
    	let windowSamples = samples.slice(i,i+averagingWindow)
    	windowSamples = applyWindow(windowSamples, hamming)
    	samples[i] = math.mean(windowSamples)
    }
    }
    
    let averaged = new Array()
    
    for (let s = startSample; s < samples.length;) {
    	averaged.push( math.mean( samples.slice(s, s+symbolWindow) )  )
    	s += symbolWindow
    }
    
    inputData = averaged
    
    if (thresholds.length != 0) {	
    	for (let s = 0; s < inputData.length; s++) {
    		let symbol = thresholds.length
			for (let t = 0; t < thresholds.length; t++) {
				if (inputData[s] > thresholds[t]) { break }
				symbol -= 1
			}
			inputData[s] = symbol
		}
    }
    
    if (sym2bit.length != 0) {
    	let newBits = new Array()
    	
    	for (let i = 0; i < inputData.length; i++) {
    		newBits.push( ...sym2bit[ parseInt(inputData[i]) ] )
    	}
    	
    	inputData = newBits
    }
    
    
    updateUI()
}

function autocorrelate(samples, rate) {
	var sum = 0
	var pd_state = 0
	var i = 0
	
  	for(i = 0; i < samples.length; i++) {
  	
    	let sum_old = sum
    	sum = 0
    	
   		for(k=0; k < samples.length-i; k++) {
   			sum += samples[i] * samples[i+2]
   		}
    
    	if (pd_state == 2 & (sum-sum_old) < 0) { 
    		return rate / i
    	}
    	
    	if (pd_state == 1 && (sum > thresh) && (sum-sum_old) > 0) {
    		pd_state = 2
    	}
    	
    	if (i == 0) { 
    		thresh = sum * 0.5;
      		pd_state = 1;
    	}
    	
  	}
  	return rate / i
}

function frequencyDetect() {
	
	var newData = new Array()
	var windowLen = 32
	
	for (let i = 0; i < inputDataNoOp.length; i++) {
		let samples = inputDataNoOp.slice(i, i+windowLen)
		newData.push( autocorrelate(samples, sampleRate) )
	}
	
	inputData = newData
	updateUI()
	
}

function correlate(frequency) {
	let period = sampleRate/frequency
	let correlated = new Array()
	
	for (let i=0; i<inputDataNoOp.length-period; i+=period) {
		let samples = inputDataNoOp.slice(i,i+period)
		let score = 0
	}
}

function fskDemodulateUndo() {
	inputData = inputDataNoOp
	updateUI()	
}

function fskDemodulate() {
	let averagingWindow = parseInt($('fskDemodulateAveraging').value)
	let crossPoint = parseFloat($('fskDemodulateCrossPoint').value) / 100
	let symbolRate = parseFloat($('fskDemodulateSymbolRate').value)
	let startSample = parseInt($('fskDemodulateStart').value)
	let thresholds = $('fskDemodulateThresholds').value.split(',')
	let sym2bit = $('fskDemodulateSym2Bit').value.split(',')
	thresholds = validateThresholds(thresholds)
	sym2bit = validateBits(sym2bit)

	var duration = inputDataNoOp.length - startSample
	
	let samples = new Array(parseInt(averagingWindow/2)).fill(0)
	let deltas = new Array(startSample).fill(0)
    
    let lastCross = 0
    
	if (symbolRate == 0) {
		symbolWindow = 1
	} else {
		symbolWindow = sampleRate / symbolRate
	}
    
    let state = 0
    for (let i = startSample; i < duration; i++) {
    	if (inputDataNoOp[i] < crossPoint & inputDataNoOp[i+1] > crossPoint & state < 1 ) {
    		let delta = i - lastCross
    		lastCross = i
    		deltas.push(delta)
    		state = 1
    	} else if (inputDataNoOp[i] > crossPoint & inputDataNoOp[i+1] < crossPoint & state > -1 ) {
    		let delta = i - lastCross
    		lastCross = i
    		deltas.push(delta)
    		state = -1
    	} else {
    		state = 0
    	}
    }
    
    for (let i = 0; i<deltas.length; i++) {
    	let frequency = ( (sampleRate/2) / deltas[i] ) / sampleRate
    	for (let x = 0; x<deltas[i];x++) {
    		samples.push(frequency)
    	}
    }
    
    for (let i = 0; i<(averagingWindow/2); i++) {
		samples[i] = samples[parseInt(averagingWindow/2)+1]
	}
    
    let averageSample = math.mean(samples)
    let maxSample = math.max(samples)
    let minSample = math.min(samples)
    let rangeSamples = maxSample - minSample
    let scale = 4 / rangeSamples
    
    for (let i = 0; i<samples.length-averagingWindow; i++) {
    	samples[i] = (samples[i] - averageSample) * scale
    }
    
    for (let i = 0; i<samples.length-averagingWindow; i++) {
    	let windowSamples = samples.slice(i,i+averagingWindow)
    	windowSamples = applyWindow(windowSamples, hamming)
    	samples[i] = math.mean(windowSamples)
    }
    
    let averaged = new Array()
    
    for (let s = startSample; s < samples.length;) {
    	averaged.push( math.mean( samples.slice(s, s+symbolWindow) )  )
    	s += symbolWindow
    }
    
    inputData = averaged	
    
    if (thresholds.length != 0) {	
    	for (let s = 0; s < inputData.length; s++) {
    		let symbol = thresholds.length
			for (let t = 0; t < thresholds.length; t++) {
				if (inputData[s] > thresholds[t]) { break }
				symbol -= 1
			}
			inputData[s] = symbol
		}
    }
    
    if (sym2bit.length != 0) {
    	let newBits = new Array()
    	
    	for (let i = 0; i < inputData.length; i++) {
    		newBits.push( ...sym2bit[ parseInt(inputData[i]) ] )
    	}
    	
    	inputData = newBits
    }
    
    updateUI()
}

function makeInt(string) {
	return parseInt(string)
}

function applyWindow(signal, func) {
  var i, n=signal.length, args=[0,n]

  // pass rest of args
  for(i=2; i<arguments.length; i++) {
    args[i] = arguments[i]
  }

  for(i=n-1; i>=0; i--) {
    args[0] = i
    signal[i] *= func.apply(null,args)
  }

  return signal;
}

function hamming (i,N) {
  return 0.54 - 0.46 * Math.cos(6.283185307179586*i/(N-1))
}

function blackmanHarris (i,N) {
  var a0 = 0.35875,
      a1 = 0.48829,
      a2 = 0.14128,
      a3 = 0.01168,
      f = 6.283185307179586*i/(N-1)

  return a0 - a1*Math.cos(f) +a2*Math.cos(2*f) - a3*Math.cos(3*f)
}

function blackmanNuttall (i,N) {
  var a0 = 0.3635819,
      a1 = 0.4891775,
      a2 = 0.1365995,
      a3 = 0.0106411,
      f = 6.283185307179586*i/(N-1)

  return a0 - a1*Math.cos(f) +a2*Math.cos(2*f) - a3*Math.cos(3*f)
}

function hann (i,N) {
  return 0.5*(1 - Math.cos(6.283185307179586*i/(N-1)))
}

function rectangular (i,N) {
  return 1
}

function collapseTopContainer() {
	if (topContainerCollapsed) {
		$('topContainerOuterCollapsed').id = 'topContainerOuter'
		$('bottomContainerOuterExpanded').id = 'bottomContainerOuter'
		topContainerCollapsed = false
	} else {
		$('topContainerOuter').id = 'topContainerOuterCollapsed'
		$('bottomContainerOuter').id = 'bottomContainerOuterExpanded'
		topContainerCollapsed = true
	}
	updateUI()
}

function validateCoefs(coefs) {
	var validCoefs = new Array()

	coefs = coefs.split('[')
	if (coefs.length > 1) { coefs = coefs[1] } else { coefs = coefs[0] }
	coefs = coefs.split(']')
	coefs = coefs[0]
	coefs = coefs.split(',')
	
	for (let x = 0; x < coefs.length; x++) {
		let coef = parseFloat(coefs[x])
		if (isNaN(coef) == false) { validCoefs.push( coef ) }
	}
	return validCoefs
}

var preFilterData = null
var filterApplied = false

function removeFIR() {
	inputDataNoOp = [...preFilterData]
	inputData = inputDataNoOp
	filterApplied = false
	updateUI()
}

function applyFIR() {
	if (filterApplied) { removeFIR() }
	
	preFilterData = [...inputDataNoOp]
	filterApplied = true

	var coefs = $('firFilterCoefs').value
	coefs = validateCoefs(coefs)
	if (coefs.length == 0) { return null }

	var newSamples = new Array()
	var samples = preFilterData
	
	for (let x = coefs.length; x < samples.length; x++) {
		let acc = 0
		for (let y = 0; y < coefs.length; y++) {
			acc += samples[x-y] * coefs[y]
		}
		newSamples.push( acc )
	}
	
	inputDataNoOp = newSamples
	inputData = newSamples
	updateUI()
} 

const topContainer = $('topContainer')
const topContainerMenu = $('topContainerMenu')
const topContainerSelect = $('topContainerSelect')

const bottomContainer = $('bottomContainer')
const bottomContainerMenu = $('bottomContainerMenu')
const bottomContainerSelect = $('bottomContainerSelect')

const menus = $('menus')
const topTools = $('topTools')
const bottomTools = $('bottomTools')
var inputData = new Array()
var inputDataNoOp = new Array()
var samples = new Array()
var samplesNoOp = new Array()
var sampleRate = 8000
var topContainerCollapsed = false


topContainerSelect.onchange = topToolSelection
bottomContainerSelect.onchange = bottomToolSelection
updateToolSelection()

const cmap = ["#000003","#000004","#000006","#010007","#010109","#01010b","#02020d","#02020f","#030311","#040313","#040415","#050417","#060519","#07051b","#08061d","#09071f","#0a0722","#0b0824","#0c0926","#0d0a28","#0e0a2a","#0f0b2c","#100c2f","#110c31","#120d33","#140d35","#150e38","#160e3a","#170f3c","#180f3f","#1a1041","#1b1044","#1c1046","#1e1049","#1f114b","#20114d","#221150","#231152","#251155","#261157","#281159","#2a115c","#2b115e","#2d1060","#2f1062","#301065","#321067","#341068","#350f6a","#370f6c","#390f6e","#3b0f6f","#3c0f71","#3e0f72","#400f73","#420f74","#430f75","#450f76","#470f77","#481078","#4a1079","#4b1079","#4d117a","#4f117b","#50127b","#52127c","#53137c","#55137d","#57147d","#58157e","#5a157e","#5b167e","#5d177e","#5e177f","#60187f","#61187f","#63197f","#651a80","#661a80","#681b80","#691c80","#6b1c80","#6c1d80","#6e1e81","#6f1e81","#711f81","#731f81","#742081","#762181","#772181","#792281","#7a2281","#7c2381","#7e2481","#7f2481","#812581","#822581","#842681","#852681","#872781","#892881","#8a2881","#8c2980","#8d2980","#8f2a80","#912a80","#922b80","#942b80","#952c80","#972c7f","#992d7f","#9a2d7f","#9c2e7f","#9e2e7e","#9f2f7e","#a12f7e","#a3307e","#a4307d","#a6317d","#a7317d","#a9327c","#ab337c","#ac337b","#ae347b","#b0347b","#b1357a","#b3357a","#b53679","#b63679","#b83778","#b93778","#bb3877","#bd3977","#be3976","#c03a75","#c23a75","#c33b74","#c53c74","#c63c73","#c83d72","#ca3e72","#cb3e71","#cd3f70","#ce4070","#d0416f","#d1426e","#d3426d","#d4436d","#d6446c","#d7456b","#d9466a","#da4769","#dc4869","#dd4968","#de4a67","#e04b66","#e14c66","#e24d65","#e44e64","#e55063","#e65162","#e75262","#e85461","#ea5560","#eb5660","#ec585f","#ed595f","#ee5b5e","#ee5d5d","#ef5e5d","#f0605d","#f1615c","#f2635c","#f3655c","#f3675b","#f4685b","#f56a5b","#f56c5b","#f66e5b","#f6705b","#f7715b","#f7735c","#f8755c","#f8775c","#f9795c","#f97b5d","#f97d5d","#fa7f5e","#fa805e","#fa825f","#fb8460","#fb8660","#fb8861","#fb8a62","#fc8c63","#fc8e63","#fc9064","#fc9265","#fc9366","#fd9567","#fd9768","#fd9969","#fd9b6a","#fd9d6b","#fd9f6c","#fda16e","#fda26f","#fda470","#fea671","#fea873","#feaa74","#feac75","#feae76","#feaf78","#feb179","#feb37b","#feb57c","#feb77d","#feb97f","#febb80","#febc82","#febe83","#fec085","#fec286","#fec488","#fec689","#fec78b","#fec98d","#fecb8e","#fdcd90","#fdcf92","#fdd193","#fdd295","#fdd497","#fdd698","#fdd89a","#fdda9c","#fddc9d","#fddd9f","#fddfa1","#fde1a3","#fce3a5","#fce5a6","#fce6a8","#fce8aa","#fceaac","#fcecae","#fceeb0","#fcf0b1","#fcf1b3","#fcf3b5","#fcf5b7","#fbf7b9","#fbf9bb","#fbfabd","#fbfcbf"]

</script>
